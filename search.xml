<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[全面屏和刘海屏适配]]></title>
    <url>%2Fposts%2Fdf0aa059.html</url>
    <content type="text"><![CDATA[关于刘海屏的适配方案有两种： 可以在刘海屏区域展示，即使部分内容被『吃掉』也没关系； 不可以在刘海屏区域展示，避免重要的信息不能被用户看到，影响使用。 本文针对这两种情况进行分析： 知识储备window.decorView.systemUiVisibility 的可选值（部分） View.SYSTEM_UI_FLAG_VISIBLE 默认标记。显示状态栏和导航栏，Activity 正常显示。 View.INVISIBLE 隐藏状态栏，同时Activity会伸展全屏显示。 View.SYSTEM_UI_FLAG_LOW_PROFILE 低调模式, 会隐藏不重要的状态栏图标 View.SYSTEM_UI_FLAG_LAYOUT_STABLE 保持整个View稳定, 常和控制System UI悬浮, 隐藏的Flags共用, 使View不会因为System UI的变化而重新layout View.SYSTEM_UI_FLAG_FULLSCREEN 状态栏隐藏，Activity全屏显示。效果同设置WindowManager.LayoutParams.FLAG_FULLSCREEN View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN 视图延伸至状态栏区域，状态栏上浮于视图之上 View.SYSTEM_UI_FLAG_HIDE_NAVIGATION 隐藏导航栏 View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION 视图延伸至导航栏区域，导航栏上浮于视图之上 View.SYSTEM_UI_FLAG_IMMERSIVE 沉浸模式, 隐藏状态栏和导航栏, 并且在第一次会弹泡提醒, 并且在状态栏区域滑动可以呼出状态栏（这样会清除之前设置的View.SYSTEM_UI_FLAG_FULLSCREEN 或 View.SYSTEM_UI_FLAG_HIDE_NAVIGATION标志）。使之生效，需要和 View.SYSTEM_UI_FLAG_FULLSCREEN，View.SYSTEM_UI_FLAG_HIDE_NAVIGATION 中的一个或两个同时设置。 View.SYSTEM_UI_FLAG_IMMERSIVE_STIKY 与上面唯一的区别是, 呼出隐藏的状态栏后不会清除之前设置的View.SYSTEM_UI_FLAG_FULLSCREEN或View.SYSTEM_UI_FLAG_HIDE_NAVIGATION标志，在一段时间后将再次隐藏系统栏）。 layoutInDisplayCutoutMode（Android P 提供） 模式 模式说明 LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT 只有当DisplayCutout完全包含在系统栏中时，才允许窗口延伸到DisplayCutout区域。 否则，窗口布局不与DisplayCutout区域重叠。 LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER 该窗口决不允许与DisplayCutout区域重叠。 LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES 该窗口始终允许延伸到屏幕短边上的DisplayCutout区域。 在刘海屏区域内展示内容，部分内容被『吃掉』不影响效果如下： 这种方案比较好适配，如果是 Android 9.0 及以上系统，使用官方提供的方案，否则设置布局延伸到状态栏即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.xiaomai.demoimport android.graphics.Colorimport android.os.Buildimport android.os.Bundleimport android.support.v7.app.AppCompatActivityimport android.view.Viewimport android.view.WindowManagerimport kotlinx.android.synthetic.main.full_screen.*class FullActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.full_screen) showTitleBar() // 如果系统版本大于等于 Android 9.0，系统支持刘海屏, 否则部分国产手机可能在 Android 8.0 就支持了刘海屏，需要在 manifest 中配置。 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123; window.attributes = window.attributes.apply &#123; layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES &#125; &#125; var isShow = true touchView.setOnClickListener &#123; isShow = !isShow if (isShow) &#123; showTitleBar() &#125; else &#123; hideTitleBar() &#125; &#125; &#125; private fun showTitleBar() &#123; // 设置状态栏透明 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; window.statusBarColor = Color.TRANSPARENT &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION or // 视图延伸至导航栏区域，导航栏上浮于视图之上 View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN // 视图延伸至状态栏区域，状态栏上浮于视图之上 &#125; &#125; /** * 已知问题，在 Vivo X21A 全屏适配有问题 */ private fun hideTitleBar() &#123; var options = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION // 隐藏导航栏 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; options = options or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION or // 视图延伸至导航栏区域，导航栏上浮于视图之上 View.SYSTEM_UI_FLAG_FULLSCREEN or // 隐藏状态栏 View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN // 视图延伸至状态栏区域，状态栏上浮于视图之上 &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; options = options or View.SYSTEM_UI_FLAG_IMMERSIVE // 沉浸模式, 隐藏状态栏和导航栏, 并且在第一次会弹泡提醒, 并且在状态栏区域滑动可以呼出状态栏 &#125; window.decorView.systemUiVisibility = options &#125;&#125; 内容重要，不能在刘海屏区域展示 思路：首先检查设备是否是刘海屏，如果是的话则设置不在状态栏显示内容，如果不是话则可以在状态栏显示。 检测设备是否是刘海屏的思路： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113class FullActivity : AppCompatActivity() &#123; private val TAG = "FullActivity" private var hasDisplayCutout = false set(value) &#123; field = value if (value) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123; window.attributes = window.attributes.apply &#123; layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER &#125; &#125; // 设置状态栏为黑色 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; window.statusBarColor = Color.BLACK &#125; &#125; else &#123; // 设置状态栏透明 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; window.statusBarColor = Color.TRANSPARENT &#125; &#125; showTitleBar() &#125; /** * 监查是否是刘海屏 */ private fun checkDisplayCutout() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123; val decorView = window.decorView decorView.post &#123; val displayCutout = decorView.rootWindowInsets.displayCutout displayCutout?.apply &#123; Log.e(TAG, "安全区域距离屏幕左边的距离 SafeInsetLeft:" + displayCutout.safeInsetLeft) Log.e(TAG, "安全区域距离屏幕右部的距离 SafeInsetRight:" + displayCutout.safeInsetRight) Log.e(TAG, "安全区域距离屏幕顶部的距离 SafeInsetTop:" + displayCutout.safeInsetTop) Log.e(TAG, "安全区域距离屏幕底部的距离 SafeInsetBottom:" + displayCutout.safeInsetBottom) &#125; hasDisplayCutout = displayCutout?.safeInsetTop ?: 0 &gt; 0 &#125; &#125; else &#123; hasDisplayCutout = DisplayCutoutUtils.isSupportDisplayCutout(this@FullActivity) &#125; &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.full_screen) checkDisplayCutout() var isShow = true touchView.setOnClickListener &#123; isShow = !isShow if (isShow) &#123; showTitleBar() &#125; else &#123; hideTitleBar() &#125; &#125; &#125; private fun showTitleBar() &#123; var newOptions = window.decorView.systemUiVisibility if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; newOptions = View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION &#125; if (hasDisplayCutout) &#123; // do nothing &#125; else &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; newOptions = newOptions or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN &#125; &#125; window.decorView.systemUiVisibility = newOptions &#125; private fun hideTitleBar() &#123; var newOptions = window.decorView.systemUiVisibility if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; newOptions = View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION &#125; if (hasDisplayCutout) &#123; // do nothing &#125; else &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; newOptions = (newOptions or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_FULLSCREEN) &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; newOptions = newOptions or View.SYSTEM_UI_FLAG_IMMERSIVE &#125; &#125; window.decorView.systemUiVisibility = newOptions &#125;&#125; 以下是通过反射获取 Android P 版本以下的设备是否是刘海屏的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146object DisplayCutoutUtils &#123; private const val TAG = "DisplayCutoutUtils" private fun Number.dp2Pixels() = TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_DIP, this.toFloat(), Resources.getSystem().displayMetrics ) fun isSupportDisplayCutout(context: Context): Boolean &#123; return getDisplayCutoutHeight(context) &gt; 0 &#125; //调用该方法，可以获取刘海屏的px值，没刘海屏则返回0 private fun getDisplayCutoutHeight(context: Context): Float &#123; var displayCutoutHeight = 0.0f //判断手机厂商，目前8.0只有华为、小米、oppo、vivo适配了刘海屏 val phoneManufacturer = Build.BRAND.toLowerCase(Locale.CHINESE) if ("huawei" == phoneManufacturer) &#123; //huawei,长度为length,单位px val haveDisplayCutoutEMUI = hasDisplayCutoutInEMUI(context) if (haveDisplayCutoutEMUI) &#123; val displayCutout: IntArray = getDisplayCutoutSizeInEMUI(context) displayCutoutHeight = displayCutout[1].toFloat() Log.e( TAG, "haveDisplayCutoutInEMUI: $haveDisplayCutoutEMUI, displayCutout: $displayCutout" ) &#125; &#125; else if ("xiaomi" == phoneManufacturer) &#123; //xiaomi,单位px val haveDisplayCutoutInMIUI = getDisplayCutoutInMIUI("ro.miui.notch", 0) == 1 if (haveDisplayCutoutInMIUI) &#123; val resourceId = context.resources.getIdentifier("notch_height", "dimen", "android") var result = 0 if (resourceId &gt; 0) &#123; result = context.resources.getDimensionPixelSize(resourceId) &#125; displayCutoutHeight = result.toFloat() Log.e( TAG, "haveDisplayCutoutInMIUI: $haveDisplayCutoutInMIUI, displayCutoutHeight: $displayCutoutHeight" ) &#125; &#125; else if ("vivo" == phoneManufacturer) &#123; //vivo,单位dp，高度27dp val haveDisplayCutoutInVIVO = hasDisplayCutoutInVivo(context) if (haveDisplayCutoutInVIVO) &#123; displayCutoutHeight = 27.dp2Pixels() Log.e( TAG, "haveDisplayCutoutInVIVO: $haveDisplayCutoutInVIVO, displayCutoutHeight: $displayCutoutHeight" ) &#125; &#125; else if ("oppo" == phoneManufacturer) &#123; //oppo val haveDisplayCutoutInOPPO = context.packageManager.hasSystemFeature("com.oppo.feature.screen.heteromorphism") if (haveDisplayCutoutInOPPO) &#123; displayCutoutHeight = 80f Log.e( TAG, "haveDisplayCutoutInOPPO: $haveDisplayCutoutInOPPO, displayCutoutHeight: $displayCutoutHeight" ) &#125; &#125; return displayCutoutHeight &#125; //huawei private fun hasDisplayCutoutInEMUI(context: Context): Boolean &#123; var ret = false try &#123; val cl = context.classLoader val hwNotchSizeUtilClass = cl.loadClass("com.huawei.android.util.HwNotchSizeUtil") val hasNotchInScreenMethod = hwNotchSizeUtilClass.getMethod("hasNotchInScreen") ret = hasNotchInScreenMethod.invoke(hwNotchSizeUtilClass) as Boolean &#125; catch (e: ClassNotFoundException) &#123; Log.e(TAG, "hasDisplayCutoutInEMUI ClassNotFoundException") &#125; catch (e: NoSuchMethodException) &#123; Log.e(TAG, "hasDisplayCutoutInEMUI NoSuchMethodException") &#125; catch (e: Exception) &#123; Log.e(TAG, "hasDisplayCutoutInEMUI Exception") &#125; finally &#123; return ret &#125; &#125; private fun getDisplayCutoutSizeInEMUI(context: Context): IntArray &#123; var ret = intArrayOf(0, 0) try &#123; val cl = context.classLoader val hwNotchSizeUtilClass = cl.loadClass("com.huawei.android.util.HwNotchSizeUtil") val getNotchSizeMethod = hwNotchSizeUtilClass.getMethod("getNotchSize") ret = getNotchSizeMethod.invoke(hwNotchSizeUtilClass) as IntArray &#125; catch (e: ClassNotFoundException) &#123; Log.e(TAG, "getDisplayCutoutSizeInEMUI ClassNotFoundException") &#125; catch (e: NoSuchMethodException) &#123; Log.e(TAG, "getDisplayCutoutSizeInEMUI NoSuchMethodException") &#125; catch (e: Exception) &#123; Log.e(TAG, "getDisplayCutoutSizeInEMUI Exception") &#125; finally &#123; return ret &#125; &#125; private fun getDisplayCutoutInMIUI(key: String, def: Int): Int &#123; var getIntMethod: Method? = null try &#123; if (getIntMethod == null) &#123; getIntMethod = Class.forName("android.os.SystemProperties") .getMethod("getInt", String::class.java, Int::class.javaPrimitiveType) &#125; return (getIntMethod?.invoke(null, key, def) as? Int)?.toInt() ?: 0 &#125; catch (e: Exception) &#123; Log.e(TAG, "Platform error: $e") return def &#125; &#125; private fun hasDisplayCutoutInVivo(context: Context): Boolean &#123; var ret = false try &#123; val classLoader = context.classLoader val ftFeatureClass = classLoader.loadClass("android.util.FtFeature") val isFeatureSupportMethod = ftFeatureClass.getMethod("isFeatureSupport", Int::class.javaPrimitiveType!!) ret = isFeatureSupportMethod.invoke(ftFeatureClass, 0x00000020) as Boolean &#125; catch (e: ClassNotFoundException) &#123; Log.e(TAG, "hasDisplayCutoutInVivo ClassNotFoundException") &#125; catch (e: NoSuchMethodException) &#123; Log.e(TAG, "hasDisplayCutoutInVivo NoSuchMethodException") &#125; catch (e: Exception) &#123; Log.e(TAG, "hasDisplayCutoutInVivo Exception") &#125; finally &#123; return ret &#125; &#125;&#125; 带虚拟导航的 Pad 设备有的 Pad 在横屏时，虚拟导航在屏幕右侧，而有的在屏幕下方。有两种计算屏幕宽高的方法，一种包含虚拟导航栏，一种不包含。 123456789101112131415161718192021222324252627282930313233fun getScreenHeight() = Resources.getSystem().displayMetrics.heightPixelsfun getScreenWidth() = Resources.getSystem().displayMetrics.widthPixels/** * 包含虚拟导航栏 */fun getRealScreenHeight(context: Context): Int &#123; return if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; val windowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager val display = windowManager.defaultDisplay val metrics = DisplayMetrics() display.getRealMetrics(metrics) metrics.heightPixels &#125; else &#123; getScreenHeight() &#125;&#125;/** * 包含虚拟导航栏 */fun getRealScreenWidth(context: Context): Int &#123; return if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; val windowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager val display = windowManager.defaultDisplay val metrics = DisplayMetrics() display.getRealMetrics(metrics) metrics.widthPixels &#125; else &#123; getScreenWidth() &#125;&#125; 参考链接 https://developer.android.com/guide/topics/display-cutout https://juejin.im/post/5b1930835188257d7541ba33 MIUI 开发文档 Vivo 开发文档]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>屏幕适配</tag>
        <tag>刘海屏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dialog 中监听键盘弹出与收起事件]]></title>
    <url>%2Fposts%2Fa5f0e43e.html</url>
    <content type="text"><![CDATA[最近遇到了一个在 Dialog 中监听键盘弹出与收起事件的需求，经过查询资料再与自己的需求相结合然后思考，最终解决了问题。现将中间遇到的问题与解决办法记录下来。 需求与效果 思路自定义 Dialog，通过设置 Dialog 的 “windowSoftInputMode” 配合监听 Dialog 所在 Window 的高度变化来判断键盘当前的状态。 实现布局1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/rootView" android:layout_width="match_parent" android:layout_height="44dp" android:layout_gravity="bottom" android:background="@android:color/white" android:orientation="horizontal"&gt; &lt;EditText android:id="@+id/editText" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_weight="1" android:background="@null" android:hint="点此参加讨论~" android:maxLines="1" android:paddingLeft="10dp" android:paddingRight="10dp" android:singleLine="true" android:textColor="@android:color/black" android:textSize="13sp" /&gt; &lt;TextView android:id="@+id/sendButton" android:layout_width="wrap_content" android:layout_height="match_parent" android:gravity="center" android:paddingLeft="15dp" android:paddingRight="15dp" android:text="发送" android:textColor="@android:color/black" android:textSize="13sp" /&gt;&lt;/LinearLayout&gt; style1234567&lt;style name="Dialog" parent="Theme.AppCompat.Dialog"&gt; &lt;item name="android:background"&gt;@android:color/transparent&lt;/item&gt; &lt;item name="android:windowBackground"&gt;@android:color/transparent&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt; &lt;item name="android:windowSoftInputMode"&gt;adjustPan|stateVisible&lt;/item&gt; &lt;item name="android:backgroundDimEnabled"&gt;false&lt;/item&gt;&lt;/style&gt; Dialog12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class MyDialog(context: Context, private val callback: Callback) : Dialog(context, R.style.Dialog) &#123; companion object &#123; private const val TAG = "MyDialog" &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.mydioalog) window?.attributes = window?.attributes?.apply &#123; width = WindowManager.LayoutParams.MATCH_PARENT // 因为 adjustPan 在键盘弹出后布局高度大于屏幕上除键盘之外的可用区域的高度时才会起效， // 而我们监听的就是布局在键盘弹出与收起时可见区域的高度的变化，从而判断键盘当前的状态的。 // 但是不同的手机屏幕高度不同，所以需要动态设置。 // 可用高度 = 屏幕高度 - 状态栏高度 height = Resources.getSystem().displayMetrics.heightPixels - getStatusBarHeight() gravity = Gravity.BOTTOM &#125; rootView.viewTreeObserver.addOnGlobalLayoutListener &#123; val decorView = window.decorView val visibleDisplayRect = Rect() // 检测当前视图所在的 Window 可见区域的大小 decorView.getWindowVisibleDisplayFrame(visibleDisplayRect) val visibleHeight = decorView.height Log.d(TAG, "visibleHeight $visibleHeight") when &#123; decorViewVisibleHeight == 0 -&gt; &#123; // do nothing &#125; decorViewVisibleHeight &gt; visibleDisplayRect.height() -&gt; callback.onKeyboardShow() else -&gt; callback.onKeyboardDismiss() &#125; decorViewVisibleHeight = visibleHeight &#125; &#125; /** * 获取状态栏高度 */ private fun getStatusBarHeight(): Int &#123; val resourceId = Resources.getSystem().getIdentifier( "status_bar_height", "dimen", "android" ) return if (resourceId &gt; 0) &#123; context.resources.getDimensionPixelSize(resourceId) &#125; else &#123; TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_DIP, 25f, Resources.getSystem().displayMetrics ).toInt() &#125; &#125; private var decorViewVisibleHeight = 0 interface Callback &#123; /** * 键盘弹出 */ fun onKeyboardShow() /** * 键盘收起 */ fun onKeyboardDismiss() &#125;&#125; 添加显示 Dialog 的点击事件在 Activity 中添加一个按钮，并为它添加点击事件如下： 12345678910button.setOnClickListener &#123; MyDialog(this, object : MyDialog.Callback &#123; override fun onKeyboardShow() &#123; textView.text = "键盘显示" &#125; override fun onKeyboardDismiss() &#123; textView.text = "键盘隐藏" &#125; &#125;).show()&#125; 此时已经可以监听到键盘的弹出与收起事件了，但是仔细看输入框会发现下半部分被键盘盖住了。 解决问题经过研究发现这与 EditText 的 background 属性有关，先把 android:background=&quot;@null&quot; 去掉，效果如下： 那么 background 设置为 null 与默认值的差别在哪里呢？我们通过 EditText 的源码找一下答案。 12345678910public class EditText extends TextView &#123; public EditText(Context context) &#123; this(context, null); &#125; public EditText(Context context, AttributeSet attrs) &#123; this(context, attrs, com.android.internal.R.attr.editTextStyle); &#125;...&#125; 从源码中可以看出 EditText 的默认 style 为 com.android.internal.R.attr.editTextStyle，接下来全局搜索看一下这个 style 的特征： 一路追踪 parent，最终发现顶级 parent 如下： 12345&lt;style name="Widget.EditText"&gt; ... &lt;item name="background"&gt;?attr/editTextBackground&lt;/item&gt; ...&lt;/style&gt; 再全局搜索 editTextBackground 关键字： 从图中可以看出有很多 item 的 name 是 editTextBackground，随便打开一个，这里就以图中选中的为例，打开文件如下： 1234567891011121314151617181920&lt;inset xmlns:android="http://schemas.android.com/apk/res/android" android:insetLeft="@dimen/edit_text_inset_horizontal_material" android:insetRight="@dimen/edit_text_inset_horizontal_material" android:insetTop="@dimen/edit_text_inset_top_material" android:insetBottom="@dimen/edit_text_inset_bottom_material"&gt; &lt;selector&gt; &lt;item android:state_enabled="false"&gt; &lt;nine-patch android:src="@drawable/textfield_default_mtrl_alpha" android:tint="?attr/colorControlNormal" /&gt; &lt;/item&gt; &lt;item android:state_pressed="false" android:state_focused="false"&gt; &lt;nine-patch android:src="@drawable/textfield_default_mtrl_alpha" android:tint="?attr/colorControlNormal" /&gt; &lt;/item&gt; &lt;item&gt; &lt;nine-patch android:src="@drawable/textfield_activated_mtrl_alpha" android:tint="?attr/colorControlActivated" /&gt; &lt;/item&gt; &lt;/selector&gt;&lt;/inset&gt; 可以看到是通过 xml 设置了一个 InsetDrawable，这里效果如同给 EditText 设置 padding。所以我们给 EditText 添加 paddingTop 和 paddingBottom，运行后发现效果 OK。 使用 FragmentDialog 注意因为 FragmentDialog 是一个 Fragment，所以既可以通过 getActivity().getWindow() 也可以使用 dialog.getWindow()，但是要注意这里应该使用 dialog.getWindow()，反之将不会有预期效果。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Dialog</tag>
        <tag>键盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客进化史]]></title>
    <url>%2Fposts%2F61f01eb0.html</url>
    <content type="text"><![CDATA[个人博客是一个不断进化的过程，在这里记录下博客优化的点点滴滴。 2019年08月07日 使用 hexo_resize_image 支持在 markdown 中设置图片大小。 2019年08月05日 文章链接使用 hexo-abbrlink 支持文章 Id。 使用 hexo-tag-aplayer 支持背景音乐。 音乐直链搜索 2019年08月01日 SEO 优化 参考文章 https://chenhuichao.com/2018/04/13/seo/seo-search-engine-principle/ https://www.jianshu.com/p/9c2d6db2f855 https://accelerator-blog.com/2019/07/27/%E5%8D%9A%E5%AE%A2%E5%8A%9F%E8%83%BD%E4%BC%98%E5%8C%96/ 使用 hexo-generator-sitemap 和 hexo-generator-baidu-sitemap 生成站点地图 使用 hexo-symbols-count-time 支持字数统计 使用 hexo-generator-searchdb 支持站内搜索 2019年05月28日 开始使用 Hexo 搭建个人博客。]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字符编码的历史演变]]></title>
    <url>%2Fposts%2Fa082b9c.html</url>
    <content type="text"><![CDATA[因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制 11111111 = 十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。 ASCII 编码的诞生由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为 ASCII 编码，比如大写字母 A 的编码是65，小写字母 z 的编码是122。 但是要处理中文，显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了 GB2312 编码，用来把中文编进去。 八仙过海，各显神通但全世界有上百种语言，日本把日文编到 Shift_JIS 里，韩国把韩文编到Euc-kr 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。 Unicode 为统一而生为了避免各国之间的编码冲突，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。 UTF-8 来优化 Unicode本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间： 字符 ASCII Unicode UTF-8 A 01000001 00000000 01000001 01000001 中 x 01001110 00101101 11100100 10111000 10101101 从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分。 如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。 总结搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式： 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。 参考文章https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000 开源工具推广你还在为开发中频繁切换环境打包而烦恼吗？快来试试 Environment Switcher 吧！使用它可以在app运行时一键切换环境，而且还支持其他贴心小功能，有了它妈妈再也不用担心频繁环境切换了。https://github.com/CodeXiaoMai/EnvironmentSwitcher]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EnvironmentSwitcher]]></title>
    <url>%2Fposts%2F1d56b016.html</url>
    <content type="text"><![CDATA[Environment Switcher 是一个在 Android 的开发和测试阶段，运用 Java 注解、APT、反射、混淆等原理来一键切换环境的工具。 目前该项目已经达成如下成就： 它具有以下特点： 配置简单 安全，不泄漏测试环境地址 不用重新打包即可一键切换环境 支持按模块配置与切换环境 支持环境切换通知回调 自动生成 切换 保存 获取 环境的逻辑代码 与项目解耦 …… 为什么不用 Gradle看到这里你可能会想，这些功能我用 Gradle 就能搞定了，为什么要用 Environment Switcher 呢？别着急，下面我们来比较一下 Environment Switcher 和 Gradle。 比较内容 Environment Switcher Gradle Application Id 不同 Gradle Application Id 相同 运行时切换环境 ✔️ ✖️ ✖️ 切换环境回调 ✔️ ✖️ ✖️ 切换环境逻辑 自动生成 需要自己实现 需要自己实现 n 套环境打包数量 1个 n个 n个 多套环境同时安装 ✔️ ✔️ ✖️ 支付等SDK包名校验 ✔️ ✖️ ✔️ 多模块环境配置 ✔️ ✔️ ✔️ 测试环境不泄露 ✔️ ✔️ ✔️ …… —— —— —— 这里就先列举这么多，仅 运行时切换环境 、打包数量、切换环境回调 这几个特点就比 Gradle 方便很多，而且 Environment Switcher 的接入成本也很低。是不是想试一试了？ 使用方法 module environmentswitcher environmentswitcher-compiler environmentswitcher-compiler-release version 配置项目的 build.gradlejava 版123456dependencies &#123; ... implementation &quot;com.xiaomai.environmentswitcher:environmentswitcher:$version&quot; debugAnnotationProcessor &quot;com.xiaomai.environmentswitcher:environmentswitcher-compiler:$version&quot; releaseAnnotationProcessor &quot;com.xiaomai.environmentswitcher:environmentswitcher-compiler-release:$version&quot;&#125; kotlin 版12345678apply plugin: &apos;kotlin-kapt&apos;...dependencies &#123; ... implementation &quot;com.xiaomai.environmentswitcher:environmentswitcher:$version&quot; kaptDebug &quot;com.xiaomai.environmentswitcher:environmentswitcher-compiler:$version&quot; kaptRelease &quot;com.xiaomai.environmentswitcher:environmentswitcher-compiler-release:$version&quot;&#125; 编写 EnvironmentConfig 文件这个类是 Environment Switcher 依赖的核心代码，所有获取、修改环境的逻辑代码都会依赖这个类中被 @Module 和 @Environment 两个注解标记的类和属性自动生成。 注意：如果你的项目中使用了 Kotlin，请使用 Java 语言编写 EnvironmentConfig，暂时还不支持使用 Kotlin 编写这个类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 环境配置类&lt;/br&gt; * * ⚠ 建议不要引用该类中的任何子类和成员变量，一但引用了非正式环境的属性，打包时混淆工具就不会移除该类，导致测试地址泄漏。&lt;/br&gt; * Environment Switcher 在编译 Release 版本时，会自动隐藏测试环境地址。&lt;/br&gt;&lt;/br&gt; * * 建议将该类中所有被 &#123;@link Module&#125; 和 &#123;@link Environment&#125; 修饰的类或成员变量用 private 修饰，&lt;/br&gt; * Environment Switcher 会在编译期间自动生成相应的 Module_XX 和 Environment_XX 静态常量。&lt;/br&gt; * 例如：通过 EnvironmentSwitcher.MODULE_APP 就可以获取到 App 模块下相应的所有环境&lt;/br&gt; */public class EnvironmentConfig &#123; /** * 整个 App 的环境 */ @Module private class App &#123; @Environment(url = &quot;https://gank.io/api/&quot;, isRelease = true, alias = &quot;正式&quot;) private String online; &#125; /** * 特殊模块 Music 的环境 */ @Module(alias = &quot;音乐&quot;) private class Music &#123; @Environment(url = &quot;https://www.codexiaomai.top/api/&quot;, isRelease = true, alias = &quot;正式&quot;) private String online; @Environment(url = &quot;http://test.codexiaomai.top/api/&quot;, alias = &quot;测试&quot;) private String test; &#125; /** * 特殊模块 News 的环境 */ @Module(alias = &quot;新闻&quot;) private class News &#123; @Environment(url = &quot;http://news/release/&quot;, isRelease = true, alias = &quot;正式&quot;) private String release; @Environment(url = &quot;http://news/test/&quot;, alias = &quot;测试&quot;) private String test; @Environment(url = &quot;http://news/test1/&quot;) private String test1; @Environment(url = &quot;http://news/sandbox/&quot;, alias = &quot;沙箱&quot;) private String sandbox; &#125;&#125; @Module被它修饰的类或接口表示一个模块，编译时会自动生成相应模块的 getXXEnvironment() 和 setXXEnvironment() 方法。一个被 @Module 修饰的类中，可以有 n (n&gt;0) 个被 @Environment 修饰的属性，表示该模块中有 n 种环境。 例如：上面的代码中，有三个类被 @Module 修饰，意味着有三个模块，其中 App 模块中，只有一个属性被 @Environment 修饰，表示该模块只有一种环境；而 Music 和 News 模块分别有 2 种和 4 种环境。 此外 @Module 还有一个可选属性 alias ，用来指定该模块的别名。该值默认为空字符串。这个属性的主要目的是在切换环境 UI 页面显示中文名称。例如：Music 和 News 模块在切换环境页面中就会分别显示 “音乐” 和 “新闻”。 注：如果你的项目中所有模块共用同一个 Host 地址，那么只需配置一个 Module 就可以了。 @Environment被它修饰的属性表示一个环境，必须指定 url 的值，此外还有两个可选属性：isRelease 和 alias。 isRelease 是一个 boolean 型的属性，默认为 false，当值为 true 时，它就是所在 Module 的默认环境，以及 App 正式发布时的环境。一个 Module 中必须有且只有一个 Environment 的 isRelease 的值为 true，否则编译会失败。 例如：Music 模块中有两种环境分别是 online（正式）和 test （测试），因为 online 的 isRelease = true，所以它就是默认环境和App 正式发布时的环境。 alias 和 @Module 中的 alias 相似，用于在切换环境的UI页面展示该环境的名字，该值默认为空字符串，如果给它指定非空字符串，则环境的名字就被指定为 alias 的值。 再次强调：一个 Module 中必须有且只有一个 Environment 的 isRelease 的值为 true，否则编译会失败。 点击菜单栏中的 “Build” -&gt; “Rebuild Project”，等待编译完成。到这里整个配置就算完成了，接下来就可以在项目中愉快的获取相应模块的环境地址了。 添加入口手动切换环境当然要有一个页面，这个页面 Environment Switcher 已经自动集成了，只需要添加一个入口跳转即可（这个入口只在 Debug 测试等内部版显示）。 例如：在“我的”页面中。 1234567891011121314151617@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; ... if (!BuildConfig.DEBUG) &#123; // only show in debug findViewById(R.id.bt_switch_environment).setVisibility(View.GONE); return; &#125; findViewById(R.id.bt_switch_environment).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // entrance of switch environment EnvironmentSwitchActivity.launch(getContext()); &#125; &#125;);&#125; 你可以使用 Environment Switcher 已经提供的 EnvironmentSwitchActivity.launch(getContext()) 方法启动；当然你也可以通过 startActivity(new Intent(getContext(), EnvironmentSwitchActivity.class)) 启动，看个人喜好了。 获取相应模块的环境地址：123String appEnvironment = EnvironmentSwitcher.getAppEnvironment(this, BuildConfig.DEBUG);String musicEnvironment = EnvironmentSwitcher.getMusicEnvironment(this, BuildConfig.DEBUG);String newsEnvironment = EnvironmentSwitcher.getNewsEnvironment(this, BuildConfig.DEBUG); 获取相应模块的环境实体类(since 1.4)：123EnvironmentBean appEnvironmentBean = EnvironmentSwitcher.getAppEnvironmentBean(this, BuildConfig.DEBUG);EnvironmentBean musicEnvironmentBean = EnvironmentSwitcher.getMusicEnvironmentBean(this, BuildConfig.DEBUG);EnvironmentBean newsEnvironmentBean = EnvironmentSwitcher.getNewsEnvironmentBean(this, BuildConfig.DEBUG); 这里需要注意的是获取相应模块的地址需要两个参数。 第一个就是一个 Context 不用解释，因为 Environment Switcher 是用 SharedPreferences 进行存储数据的。 第二个参数是一个 boolean 型的值，如果为 true 表示当前为 Debug 或测试等内部使用版本，此时获取到的地址是我们手动切换保存的地址；而如果为 false 表示当前为要发布给用户使用的版本，此时获取到的地址为我们在 @Environment 中指定 isRelease = true 的地址，手动切换的环境地址不再生效。 添加监听事件Environment Switcher 支持切换环境回调，你可以通过以下方法添加，需要注意的是不要忘记在不需要监听环境切换事件时移除监听事件。 123456789101112131415161718192021222324public class MainActivity extends AppCompatActivity implements OnEnvironmentChangeListener&#123; private static final String TAG = &quot;MainActivity&quot;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 添加监听事件 EnvironmentSwitcher.addOnEnvironmentChangeListener(this); &#125; @Override public void onEnvironmentChanged(ModuleBean module, EnvironmentBean oldEnvironment, EnvironmentBean newEnvironment) &#123; Log.e(TAG, module.getName() + &quot;由&quot; + oldEnvironment.getName() + &quot;环境，Url=&quot; + oldEnvironment.getUrl() + &quot;,切换为&quot; + newEnvironment.getName() + &quot;环境，Url=&quot; + newEnvironment.getUrl()); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // 移除监听事件 EnvironmentSwitcher.removeOnEnvironmentChangeListener(this); &#125;&#125; 切换SDK开发环境我们在项目中一般会依赖第三方提供的SDK，而且这些SDK也会提供测试环境，如果要在App内切换环境，使用上面的方法就不行了。那该怎么办呢？ 例如我们的“直播”模块是引用的SDK，我们可以这样做： 首先在 EnvironmentConfig.java 中配置”直播”模块 12345678910public class EnvironmentConfig &#123; @Module(alias = &quot;直播&quot;) private class Live &#123; @Environment(url = &quot;online&quot;, isRelease = true, alias = &quot;正式&quot;) private String online; @Environment(url = &quot;test&quot;, alias = &quot;测试&quot;) private String test; &#125;&#125; url 在这里只是用来区分环境，不用为真实的 url，但要保证同一模块中每个环境的 url 不同。 在 Application 中添加监听 123456789101112EnvironmentSwitcher.addOnEnvironmentChangeListener(new OnEnvironmentChangeListener() &#123; @Override public void onEnvironmentChanged(ModuleBean module, EnvironmentBean oldEnvironment, EnvironmentBean newEnvironment) &#123; if (module.equals(EnvironmentSwitcher.MODULE_LIVE)) &#123; if (newEnvironment.equals(EnvironmentSwitcher.LIVE_ONLINE_ENVIRONMENT)) &#123; // 调用 SDK 切换环境的方法，正式环境 &#125; else if (newEnvironment.equals(EnvironmentSwitcher.LIVE_TEST_ENVIRONMENT)) &#123; // 调用 SDK 切换环境的方法，测试环境 &#125; &#125; &#125;&#125;); 利用 Environment Switcher 的环境切换回调，实现切换 SDK 环境。 好了，关于Environment Switcher 的介绍就到此为止吧，更多使用介绍可参考Demo，Demo 中有 Environment Switcher 结合 Retrofit 使用的详细实现过程。]]></content>
      <categories>
        <category>开源</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>EnvironmentSwitcher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentModificationException 异常分析与解决方法]]></title>
    <url>%2Fposts%2F9041b2de.html</url>
    <content type="text"><![CDATA[本文主要从源码的角度分析 ConcurrentModificationException 发生的原因，以及解决办法。 需求与实现需求：从一个集合中找出指定的元素并将其删除。 问题代码： 1234567891011121314ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; list.add(i);&#125;list.forEach(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) &#123; if (integer == 5) &#123; list.remove(integer); &#125; &#125;&#125;); 异常堆栈： 12345Exception in thread "main" java.util.ConcurrentModificationException at java.util.ArrayList.forEach(ArrayList.java:1260) ...Process finished with exit code 1 原因排查从异常的堆栈信息中可以看出，在 ArrayList 的 forEach() 方法中抛出异常，那就先看一下这个方法。 1234567891011121314151617public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings("unchecked") final E[] elementData = (E[]) this.elementData; final int size = this.size; // 循环体内代码执行需要满足的条件有两个： // 1. modCount == expectedModCount // 2. i &lt; size for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; 经过对 forEach() 方法的源码分析，发现 modCount != expectedModCount 会导致 for 循环退出，并且抛出 ConcurrentModificationException。 从第 3 行代码 final int expectedModCount = modCount 中可以知道，初始状态 expectedModCount 和 modCount 的值是相等的，那么是什么原因导致它们的值不相等进而抛出异常的呢？ 原因是 ArrayList 的修改操作（remove 或 add）会导致 modCount 的值发生变化。这里以 remove 方法为例进行分析证明： 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 读完上面的源码会发现 remove 方法并没有修改 modCount 的值啊。别着急，再仔细观察会发现无论怎样，最终会执行 fastRemove 方法。再来看一下这个方法的实现： 123456789private void fastRemove(int index) &#123; // 修改 modCount modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 这次没错了吧。 所以在 forEach() 方法中使用 ArrayList.remove() 删除元素会抛出异常的原因是：由于 ArrayList 执行 remove 方法后，modCount 的值加 1，当 forEach 中的循环检查两个条件时，会因 modCount == expectedModCount 不成立导致 for 循环退出，进而抛出 ConcurrentModificationException 异常。 由此可见，forEach 循环只适用于对 ArrayList 的遍历，但是不可以对 ArrayList 进行添加或删除操作，否则将抛出异常。 现在问题的原因找到了，那么我们应该怎么解决呢？ 解决办法方法一：使用普通的 for 循环1234567891011ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; list.add(i);&#125;for (int i = 0; i &lt; list.size(); i++) &#123; if (i == 5) &#123; list.remove(i); &#125;&#125; 运行代码，发现没有抛出异常。问题解决！ 但是，如果需求改为删除所有元素呢？ 12345678910111213ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; list.add(i);&#125;for (int i = 0; i &lt; list.size(); i++) &#123; list.remove(i);&#125;int size = list.size();System.out.println("执行完毕 list.size() = " + size); 先猜一下运行结果是什么，再往下看。 ——– 这里是分隔线（这里先插播一条广告，广告之后更加精彩！哈哈！！！）———— 你还在为开发中频繁切换环境打包而烦恼吗？快来试试 Environment Switcher 吧！使用它可以在app运行时一键切换环境，而且还支持其他贴心小功能，有了它妈妈再也不用担心频繁环境切换了。https://github.com/CodeXiaoMai/EnvironmentSwitcher目前该项目已经达成如下成就： ——————- 这里是分隔线（广告结束，精彩继续！！！）——————– 好了，回归正题你猜出结果了吗？看看你猜的对下对。 运行结果为： 1执行完毕 list.size() = 5 咦？明明是遍历 list 的每个元素并把它们删除，为什么最后还有 5 个元素呢？ 这是因为 ArrayList 内部使用数组存储数据，10 个元素依次存储在数组的第 0 个位置开始到第 9 个位置，当中间有一个元素删除时，后面的所有元素会向前移动，保证中间没有空余。所以当第 0 个位置的元素删除完毕后，本来在第 1 个位置的元素变成第 0 个元素，但由于 i++ 后 i = 1，下次执行删除操作时会删除最新的第 1 个位置的元素，而第 0 个位置的元素因被跳过而不会被删除，同理当后面的元素被删除时也会有跳过，这就是为什么最终会有 5 个元素的原因。 所以如果只是在遍历 ArrayList 的同时删除指定的元素后并退出循环，这样是没有问题的，因为删除元素后，不会进行其他操作。但是如果删除所有元素，就需要做一些特殊的处理了，具体处理如下： 1234for (int i = 0; i &lt; list.size(); i++) &#123; list.remove(i); i--;&#125; 方法二：使用 Iterator12345678910111213ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; list.add(i);&#125;Iterator&lt;Integer&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; if (iterator.next() == 5) &#123; iterator.remove(); &#125;&#125; 如果要删除所有元素呢？ 123456789101112ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; list.add(i);&#125;Iterator&lt;Integer&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; iterator.next(); iterator.remove();&#125; 运行结果： 1执行完毕 list.size() = 0 从运行结果可以知道，程序正常运行而且完全符合预期。为什么使用 Iterator 可以正常遍历并且删除所有元素呢？下面从源码的角度分析： 首先看，list.iterator() 的实现： 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 这个方法创建并返回一个 Itr 类的实例。通过查看源码可以发现 Itr 实现了 Iterator 接口，这不正是我们需要的吗？接下来依次看 iterator.hasNext()、iterator.next() 以及 iterator.remove() 方法：（前方高能，请注意准备好脑子！！！） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; // 因为 Itr 是 ArrayList 的内部类，所以可以直接访问 ArrayList 的 modCount。 Itr() &#123;&#125; public boolean hasNext() &#123; // 如果当前 cursor 不指向最后一个元素后面的索引位置， // 说明当前 cursor 所在位置后面还有没有遍历到的元素，返回 true。 return cursor != size; // 因为 Itr 是 ArrayList 的内部类，所以可以直接访问 ArrayList 的 size。 &#125; /** * 首先检查 modCount == expectedModCount 是否成立， * 如果不成立直接抛出 ConcurrentModificationException； * 否则按下面的逻辑运行： * 返回当前 cursor 所在位置的元素， * lastRet 的值更新为当前 cursor 的值， * cursor 的值加 1，即指向下次要访问的元素位置。 */ @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; /** * 与直接使用 ArrayList 的 remove() 方法不同的是， * 该方法会更新 expectedModCount 的值为 modCount。 * 这也正是为什么通过 List.iterator() 遍历的同时进行 * iterator().remove() 操作，不会发送异常的原因。 */ public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125;&#125; 总结： 使用 List.iterator() 遍历集合的同时进行 iterator().remove() 操作，不会发送异常的原因是：Iterator.remove() 会在执行 ArrayList 的 remove() 后，重新将 expectedModCount 的值更新为 modCount 的值。这样运行 checkForComodification() 方法时，才会正常运行。 方法三：使用增强 for 循环增强 for 循环是迭代器的简化书写格式，和 iterator 遍历的效果是一样的，也就说增强 for 循环的内部也就是调用 iterator 实现的，只不过获取迭代器由 jvm 完成，不需要我们获取迭代器而已。但是增强 for 循环有些缺点，例如不能在增强 for 循环里动态的删除集合内容（虽然内部也使用了 Iterator 但在删除时因为拿不到 Iterator，所以不能通过 Iterator 删除）、不能获取下标等。 所以这种方式只适用于删除一个指定元素后，立即退出循环的情况。 123456789101112ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; list.add(i);&#125;for (Integer integer : list) &#123; if (integer == 5) &#123; list.remove(integer); break; &#125;&#125; 总结经过上面对异常发生的原因以及 3 种解决办法的分析，可以得出以下结论： 只要是在遍历时直接通过调用 ArrayList.remove() 移除元素都是不安全的，普通的 for 循环和增强 for 循环适用于删除一个元素后就退出循环体；而 forEach() 循环是坚决不可以执行删除操作的（因为它是程序员无法控制退出循环的），否则会抛出异常。最安全的方法是使用 Iterator 进行遍历的同时，并且必须使用 Iterator 提供的 remove() 方法进行删除操作。 扩展上面分析是 remove() 操作，那 add() 操作呢？ 按照思路应该也是使用 Iterator 的 add 之类的方法，但是当我们写代码的时候会发现，唉？唉？唉？唉？我 iterator 点，iterator 点…… 为什么没有点出来 add 之类的方法？ 这是因为 Iterator 接口只提供了 remove() 方法，F***K，这可让我如何是好？别急，List 接口还提供了一个 listIterator() 方法，这个方法返回的对象是可以进行 add 操作的，我们来看一看下面的代码： 123456789101112131415161718ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();// 初始化 list 中的值为 0,2,4,6,8for (int i = 0; i &lt; 10; i += 2) &#123; list.add(i);&#125;ListIterator&lt;Integer&gt; iterator = list.listIterator();// 在每个元素后面追加一个比自己大 1 的元素while (iterator.hasNext()) &#123; Integer next = iterator.next(); iterator.add(next + 1);&#125;for (Integer integer : list) &#123; System.out.print(integer);&#125; 运行结果： 10123456789 通过查看源码，可以发现 list.listIterator() 方法如下： 123public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0);&#125; 这个方法返回一个 ListItr 类的实例，并且这个类实现了 ListIterator 接口。 ListIterator 是一个在继承了 Iterator 接口的同时又额外提供了 add() 、set() 等方法的接口，如下图。 再看一下 ListItr 这个类： 12345678910111213141516171819private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ...... /** * 同 Itr 的 remove 方法一样，先在集合中添加元素， * 最后将 modCount 的值赋给 expectedModCount */ public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125;&#125; ListItr 不但实现了 ListIterator 接口，而且继承了 Itr 类（上面已经分析过），从源码中可以发现 ListItr 内没有实现 remove() 方法，显然这是直接复用它的父类 Itr 的 remove() 方法。 所以，如果在遍历的同时只是进行 remove 操作，既可以使用 iterator 也可以使用 listIterator；而要进行 add 操作，就必须使用 listIterator 了。 LinkedList 和 ArrayList 略有不同，虽然它的 iterator() 和 listIterator() 方法返回的接口类型不同，但是仔细分析源码会发现其实内部都是 ListItr 对象。]]></content>
      <categories>
        <category>Java</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>ConcurrentModificationException</tag>
        <tag>ArrayList</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
</search>
