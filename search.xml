<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java内存模型]]></title>
    <url>%2Fposts%2F2a3a86ee.html</url>
    <content type="text"><![CDATA[Java 内存模型是多线程并发的基础，理解了 Java 内存模型能够对多线程并发中的问题迎刃而解。Java 的内存模型在很大程度上与硬件的交互模型类似，所以先了解一下硬件的交互。 硬件的效率与一致性在计算机中绝大多数的运算任务不可能只靠处理器就能完成，处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个 I/O 操作是很难避免的。由于计算机的存储设备比处理器的运算速度慢几个数量级的差距，所以现代的计算机系统加入了一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲。这个高速缓存（Cache）存储运算需要的数据，让运算能快速进行，当运算结束后再从缓存 同步回内存中，这样处理器就不用等待缓慢的内存读写了。 虽然高速缓存解决了处理器与内存之间的 I/O 瓶颈，但同时又引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，当多个处理器的运算任务都涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致，数据同步回主内存时，主内存又该以哪个缓存的数据为准。所以为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议。处理器、高速缓存、主内存之间的关系如下图： Java 内存模型Java 内存模型（Java Memory Model，JMM）的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。它是用来屏蔽各种硬件和操作系统的内存访问差异，以实现 Java 程序在各种平台下都能达到一致的内存访问效果。 Java 内存模型规定所有的变量都存储在主内存（Main Memory）中（此处的主内存指的是虚拟机内存的一部分）。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，不能直接读写主内存中的变量（volatile 变量依然有工作内存的拷贝，但是由于它特殊的操作有顺序性规定，所以看起来如同直接在主内存中读写访问一样）。不同的线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的关系如下： 由上图可以看出，Java 内存模型图与硬件的一致性关系图非常相似。 1234Java 线程 &lt;==&gt; 工作内存 &lt;==&gt; Save 和 Load 操作 &lt;==&gt; 主内存 | | | | | | | | 处理器 &lt;==&gt; 高速缓存 &lt;==&gt; 缓存一致性协议 &lt;==&gt; 主内存 Java 内存间的交互操作关于主内存与工作内存之间具体的交互协议，就是一个变量如何从主内存拷贝到工作内存，以及如何从工作内存同步回主内存之类的实现细节。Java 内存模型中定义了 8 种操作来完成，虚拟机必须保证下面下面的第一种操作都原子的，不可再分的。 lock unlock read load use assign store write Java 内存模型还规定了在执行上述8种操作时必须满足如下规则： 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。 这8种内存访问操作以及上述规则限定，再加 volatile 的一些特殊规定，就已经完全确定了Java程序中哪些内存访问操作在并发下是安全的。由于这种定义相当严谨但又十分烦琐，实践起来很麻烦，所以这种定义的一个等效判断原则 —— 先行发生原则（文章最后介绍），用来确定一个访问在并发环境下是否安全。 volatile volatile 是 Java 虚拟机提供的最轻量级的同步机制。 Java 内存模型对 volatile 专门定义了一些特殊的访问规则，当一个变量定义为 volatile之后，它将具备两种特性：保证此变量对所有线程的可见性；禁止指令重排序优化。 可见性『可见性』是指当一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递需要通过主内存来完成。除了volatile之外，Java还有两个关键字能实现可见性，即synchronized和final。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的，而final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看见final字段的值。 一个错误的结论：由于 volatile 变量对所有线程是立即可见的，对 volatile 变量所有的写操作都能立刻反应到其他线程中，所以 volatile 变量的运算在并发下是安全的。 这句话的论据没有错，但并不能得出 “volatile 变量的运算在并发下是安全的” 这个结论。原因是：Java 中的运算并非原子操作。 例如一个累加运算如下： 12345public static volatile int number = 0;public static void increase() &#123; number++;&#125; 把这段代码反编译后，得到的字节码如下： 123456789public static volatile int number;public static void increase(); Code: 0: getstatic #2 // Field number:I 3: iconst_1 4: iadd 5: putstatic #2 // Field number:I 8: return 从字节码中可以发现，只有一行代码的 increase() 方法在 Class 文件中却有 4 条字节码指令构成（不算 return），所以很容易就明白并发失败的原因了：当getstatic指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值加大了，而再操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能把较小的race值同步回主内存之中。 所以 volatile 变量在不符合以下两条规则时，仍然要通过加锁来保证原子性： 运算结果并不依赖变量的当前值（正例：boolean，反例：累加），或者能够确保只有一个线程修改变量的值。 变量不需要与其他的状态变量共同参与不变约束。意思是：volatile 没办法保证和其他变量一起用时，多线程对 volatile 变量和其他变量操作的原子性。 指令重排序『指令重排序』是在保证不影响当前线程执行结果的前提下对代码执行顺序做出一些调整，但这个调整在多线程并发时可能会影响其他线程的结果。这也就是 Java 内存模型中所谓的『线程中表现为串行』的语义。 什么时候使用 volatilevolatile 变量读操作的性能与普通变量几乎没有差别，但是写操作可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。大多数场景下 volatile 的总开销比锁低，当在 volatile 与锁之中选择时，如果满足 volatile 的使用场景就使用它，否则使用锁。 Java 内存模型的三个特征 原子性（Atomicity）：由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问读写是具备原子性的。如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。 可见性：指当一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。 有序性：Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。 先行发生原则（Happens-before）『先行发生』是指 Java 内存模型中定义的两项操作之间的偏序关系，如果操作 A 先行发生于操作 B，其实就是说在发生操作 B 之前，操作 A 的影响能被操作 B 观察到。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。 下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。 程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。 管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是同一个锁，而『后面』是指时间上的先后顺序。 volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的『后面』也是指时间上的先后顺序。 线程启动规则：Thread 对象的 start() 方法先行发生于此线程的每一个动作。 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值等手段检测到线程已经终止执行。 线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted() 方法检测到是否有中断发生。 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。 传递性：如果操作 A 等待发生于操作 B，操作 B 先生发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。 一个例子判定操作是否具备顺序性： 12345678private int value = 0;pubilc void setValue(int value) &#123; this.value = value; &#125;public int getValue()&#123; return value;&#125; 假设存在线程A和B，线程A先（时间上的先后）调用了“setValue(1)”，然后线程B调用了同一个对象的“getValue()”，那么线程B收到的返回值是什么？ 我们依次分析一下先行发生原则中的各项规则: 由于两个方法分别由线程A和线程B调用，不在一个线程中，所以程序次序规则在这里不适用； 由于没有同步块，自然就不会发生lock和unlock操作，所以管程锁定规则不适用； 由于value变量没有被volatile关键字修饰，所以volatile变量规则不适用； 后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起，因此我们可以判定尽管线程A在操作时间上先于线程B，但是无法确定线程B中“getValue()”方法的返回结果，换句话说，这里面的操作不是线程安全的。 那怎么修复这个问题呢？我们至少有两种比较简单的方案可以选择：要么把getter/setter方法都定义为synchronized方法，这样就可以套用管程锁定规则；要么把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景，这样就可以套用volatile变量规则来实现先行发生关系。 通过上面的例子，我们可以得出结论：一个操作“时间上的先发生”不代表这个操作会是“先行发生”，那如果一个操作“先行发生”是否就能推导出这个操作必定是“时间上的先发生”呢？很遗憾，这个推论也是不成立的，一个典型的例子就是多次提到的“指令重排序”,如下所示： 123// 以下操作在同一个线程在执行int i = 1;int j = 2; 两条赋值语句在同一个线程之中，根据程序次序规则，“int i=1”的操作先行发生于“int j=2”，但是“int j=2”的代码完全可能先被处理器执行，这并不影响先行发生原则的正确性，因为我们在这条线程之中没有办法感知到这点。 上面两个例子综合起来证明了一个结论：时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntentService源码解析]]></title>
    <url>%2Fposts%2F9e86a7ad.html</url>
    <content type="text"><![CDATA[IntentService 是 Service 的子类，当然也是用于处理耗时操作的，通过 startService(Intent) 启动，并且会在工作线程中处理每个 Intent，并在操作结束或不正常时自行停止。 要看懂 IntentService 的源码，必须熟悉 Handler 机制，不明白的建议先了解一下 Handler 机制。 IntentService 的用法要使用 IntentService，只需要创建一个类继承 IntentService 并实现抽象方法 onHandleIntent（Intent）。 12345678910111213141516171819public class InitializeService extends IntentService &#123; private static final String ACTION_INIT = "service.action.INIT"; public InitializeService() &#123; super("InitializeService"); &#125; public static void start(Application context) &#123; Intent intent = new Intent(context, InitializeService.class); intent.setAction(ACTION_INIT); context.startService(intent); &#125; @Override protected void onHandleIntent(@Nullable Intent intent) &#123; // 处理耗时操作 &#125;&#125; 就这么简单，我们只需要把精力用在重写 onHandleIntent 方法处理耗时操作就可以了，也不用开启新的线程。 而如果直接使用 Service，恐怕就没那么简单了，我们需要处理很多事情，比如耗时操作要单独创建一个工作线程，操作结束后要停止 Service 运行等等。 那么 IntentService 是怎么实现将 Service 中复杂的逻辑简化为只需要实现一个 onHandleIntent 方法就可以的呢？ 其实 IntentService 是通过对 Service 的各个生命周期进行处理，并结合了 Android 中强大的 Handler 机制来完成的。 下面就根据 Service 的生命周期，分析 IntentService 的实现原理。 先借用 Android 官网的 Service 生命周期图看一下： 下面以通过 startService 启动 IntentService 为例，进行分析。 OnCreate下面是 IntentService 的 onCreate 方法的源码： IntentService.java 1234567891011private volatile Looper mServiceLooper;private volatile ServiceHandler mServiceHandler;@Overridepublic void onCreate() &#123; super.onCreate(); HandlerThread thread = new HandlerThread("IntentService[" + mName + "]"); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper);&#125; 创建一个 HandlerThread，也就是一个子线程，并启动这个线程。获取这个线程绑定的 Looper，再利用这个 Looper 创建一个 Handler，因为这个 Looper 是与 HandlerThread（一个新的工作线程）绑定的，所以与这个 Looper 关联的 Handler 也就在 HandlerThread 线程中接收与处理消息。 HandlerThread 启动后，必然会运行 run() 方法，接下来看一下 HandlerThread.run()。 HandlerThread.java 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 该方法主要是标准的 Looper 的使用步骤 */ @Overridepublic void run() &#123; mTid = Process.myTid(); // 1. Looper.prepare(); synchronized (this) &#123; // 2. 将当前线程的 Looper 赋值给 mLooper，并通知正在等待使用 mLooper 的地方 mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); // 3. Looper.loop(); mTid = -1;&#125;/** * 此方法将返回与此线程关联的Looper。 * 如果未启动此线程或 isAlive() 返回false，此方法将返回null。 * 如果该线程已经启动，该方法将阻塞，直到looper被初始化。 */public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper;&#125; 当 HandlerThread 启动后，在 run 方法中会调用 Looper.prepare() 方法创建 Looper 的实例并与 HandlerThread 线程相关联，然后调用 Looper.loop() 方法开始循环处理消息。 onStartCommand/onStart123456789101112131415161718192021222324252627282930@Overridepublic void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg);&#125;/** * 我们不应该在 InentService 中重写此方法，而应该重写 onHandleIntent()， * 当 IntentService 收到一个请求时，系统会调用它。 */@Overridepublic int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;&#125;/** * onBind 方法默认返回 null，并且通过 bindService() 启动的 IntentService 的生命周期是： * onCreate()-&gt;onBind()-&gt;onunbind()-&gt;onDestory(); * 这种方式不会调用 onStartCommand() 和 onStart() 方法， * 所以不会将消息发送到消息队列中去，也就不会执行 onHandleIntent() 回调， * 失去了 IntentService 的优势。所以不建议使用这种方式。 */@Override@Nullablepublic IBinder onBind(Intent intent) &#123; return null;&#125; onStartCommand 方法内部会调用 onStart 方法，onStart 方法中就是创建一个 Message 对象，并把 Intent 和 startId 保存到这个 Message 对象中，最后通过 mServiceHandler 发送消息。 123456789101112131415161718192021222324private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125;&#125;/** * 这个方法在工作线程上执行，并处理耗时操作，一次只处理一个 Intent。 * 即若一个任务正在IntentService中执行，此时你再发送1个新的任务请求， * 这个新的任务会一直等待直到前面一个任务执行完毕后才开始执行。 * 因为在 Service 没有被销毁前，onCreate()只会调用一次，所以只会创建一个工作线程； * 当多次调用 startService(Intent)时（即 onStartCommand（）也会调用多次），其实不会创建新的工作线程，只是把消息加入消息队列中并等待执行。 * 处理消息的 Looper，Handler，以及 onHandleIntent() 都是同一个线程， * 所以当 Looper 从消息队列中取出一条消息后，只有在 onHandleIntent() 执行完毕后，才会取下一条消息。 * 当所有请求都被处理后，IntentService 就会停止，我们也不用手动停止。 */@WorkerThreadprotected abstract void onHandleIntent(@Nullable Intent intent); 因为 ServiceHandler 是在子线程中接收消息，所以handleMessage() 方法自然也就在子线程中处理，onHandleIntent() 同样如此，最后处理结束后调用 stopSelf 方法停止 Service 运行。 为什么当有多个任务时 hanndleMessage 中 stopSelf(msg.arg1) 不会终止 Service？因为在 onStartCommand 中会传入一个 startId，这个 startId 保存在 msg.arg1 中，因此每次调用 startService() 都会回调这个方法，所以每个 startId 也就不同， 也就是说，每当我们调用startService()启动一个服务时，不但会在其对应的 ServiceRecord 节点的 pendingStarts 里插入一个新的 StartItem 节点，而且会为这个 StartItem 节点生成一个新的 id 号，这个 id 号就是日后的 startId（生成id号时，采用的办法是最简单的加1操作）。 而在 stopSelf() 中传入的也是这个 startId，所以在关闭时，会关闭这个 startId 指定的任务，同时会判断是否是最后一个 startId，如果是最后一个才真正的结束 Service，否则不结束。 也就是按序从 ServiceRecord 的 deliveredStarts 列表中删除 StartItem 节点，直到所删除的是 startId 参数对应的 StartItem 节点，如果此时尚未抵达 ServiceRecord 内部记录的最后一个 start Id 时，则说明此次 stopSelf()操作没必要进一步结束service，那么直接 return false 就可以了。只有在所删除的 startItem 节点的确是最后一个 startItem 节点时，才会调用 bringDownServiceIfNeededLocked() 去结束 service。这就是为什么 IntentService 的 ServiceHandler 在处理完消息后，可以放心调用 stopSelf() 的原因。 参考文章https://my.oschina.net/youranhongcha/blog/785387 onDestroy1234@Overridepublic void onDestroy() &#123; mServiceLooper.quit();&#125; 当 Service 真正停止时会回调 onDestroy() ，这时 mServiceLooper 会退出循环。 IntentService VS Service 运行线程 结束 IntentService 自动创建工作线程处理任务 自动结束，不需要处理。 Service 主线程不能处理耗时操作，需编写代码创建子线程。 需要主动调用stopService() IntentService VS 普通线程 线程优先级 IntentService 高不容易被系统杀死 普通线程 低若进程中无活动的四大组件，则该线程的优先级非常低，容易被系统杀死。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>IntentService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler消息机制源码解析]]></title>
    <url>%2Fposts%2Ff49e176e.html</url>
    <content type="text"><![CDATA[Handler 消息机制是由 Message MessageQueue Handler Looper 共同完成的。 Handler 消息机制是用于在同一个进程中的多个线程之间进行通信的。由于工作线程与主线程共享地址空间，即 Handler 实例对象 mHandler 位于线程间共享的内存堆上，所以工作线程与主线程都能直接使用该对象，只需要注意多线程的同步问题。工作线程通过 mHandler 向其成员变量 MessageQueue 中添加新 Message，主线程一直处于 loop() 方法中，当收到新的 Message 时按照一定规则分发给相应的 handleMessage() 方法来处理。所以说，Handler 消息机制用于同进程的线程间通信的核心是线程间共享内存空间，而不同进程拥有不同的地址空间，也就不能用 Handler 来实现进程间通信。 既然是用来通信的消息机制，那用什么来通信呢？当然是 Message，下面就先介绍一下 Message。 MessageMessage 默认提供了两个 int 属性和一个 object 属性，能够满足我们大多数情况的需求。 关于 Message 主要需要注意的是，怎样正确的创建一个 Message 对象？尽管 Message 的构造函数是公共的，但是最好的方法（效率高，避免重复创建对象）却是通过调用 Message.obtain() 或者 Handler.obtainMessage() 方法，从消息池中回收的 Message 中获取。 1234Message next;private static Message sPool;private static int sPoolSize = 0;private static final int MAX_POOL_SIZE = 50; 上面几个属性是 Message 中声明的，每个 Message 对象都可以通过为 next 属性赋值，添加一个后继元素，这样多个 Message 对象就组成了一个单链表；而 sPool 就是链表的表头位置的 Message 对象，也就是头指针。此外我们还可以了解到这个链表的最大长度为 50。 那么这个链表有什么用呢？ 答案就是用来保存已经用过的 Message，这个保存是通过 recyclerUnchecked() 方法实现的，而且这个机制是在 Looper 中消息被处理完成之后触发的。 123456789101112131415161718192021222324252627282930313233public void recycle() &#123; if (isInUse()) &#123; if (gCheckRecycle) &#123; throw new IllegalStateException("This message cannot be recycled because it " + "is still in use."); &#125; return; &#125; recycleUnchecked();&#125;void recycleUnchecked() &#123; flags = FLAG_IN_USE; // 将所有数据清空 what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; // 如果当前消息池未满就把 Message 插入到消息池的头部 next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; 现在明白了消息池中的消息是怎么来的，再来看 obtain() 这个方法是怎么从消息池中取出消息的。 12345678910111213141516public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; // 如果消息池的第一个消息 sPool 不为null，也就意味着消息池中有消息，就将它从消息池中取出来。 Message m = sPool; // 将 sPool 改为消息池的第二个消息 sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; // 如果消息池中没有 Message，就创建新的 Message。 return new Message();&#125; 现在已经通过正确的方式得到了一个 Message 对象实例，那么我们发送的消息在哪保存呢？下面就到了 MessageQueue 出场了。 MessageQueueMessageQueue 的构造方法： 1234567// True if the message queue can be quit.private final boolean mQuitAllowed;MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit();&#125; mQuitAllowed 用来标记这个消息队列是否可以退出，事实也证明这个变量只在 quit() 方法中用到了，主线程是不可以退出的。我们创建的 MessageQueue 都是可以退出的，严格来说是必需退出的。因为这个 MessageQueue 是在 Looper 中创建的，而且创建时也确实是传入的 true，后面在 Looper 中会介绍。 MessageQueue 的两大主要作用就是： 保存消息：boolean enqueueMessage(Message msg, log when) 取出消息：Message next() enqueueuMessage()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; // mMessages 代表链表头结点的消息 Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 如果 p 为 null 表示 MessageQueue 中没有消息，如果 when = 0 或者触发时间比链表头结点的消息时间还早，就直接插入链表头部 // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; // 要插入 msg 的前驱元素 prev = p; // 要插入 msg 的后继元素 p = p.next; if (p == null || when &lt; p.when) &#123; // p 为 null 表示到达链表末尾，when &lt; p.when 表示新 msg 的触发时间比 p 的早，插入到它的前面就行了。 break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 可以看出，MessageQueue 是将每个 Message 按照 when(触发时间)进行排列，并存储到链表中，当有新的 Message 需要添加时，从链表的第一个 Message 开始循环遍历，直到新 Message 的 when 比当前遍历到的 Message 的 when 要早，就把新 Message 插入到当前遍历到的 Message 之前，如果没有遍历到，就将新的 Message 插入到链表尾部。 next()主要是从 MessageQueue 中取出头部的消息，具体细节都是涉及到数据结构的操作。 removeMessages()Handler 中提供了几个 removeMessages() 和 removeCallbacks() 以及 removeCallbacksAndMessages() 方法，最终都是调用内部的 messageQueue 的 removeMessages() 方法，将消息从 MessageQueue 中移除。 现在 Message 和保存 Message 的 MessageQueue 都了解了，可谓是万事具备只欠东风了，下面开始发射。。。 Handler Handler 允许我们发送和处理与当前线程关联的 MessageQueue 中的 Message 对象。每个 Handler 实例都与单个线程以及该线程的消息队列相关联。当创建一个新的 Handler 时，它绑定到创建它的线程和线程的消息队列上。这样，它就可以将消息传递到消息队列，并在消息从队列出来时执行它们。 当应用程序创建一个进程时，其主线程将专门运行一个消息队列，负责管理顶层应用程序对象（activities， broadcast receivers 等）以及它们创建的任何窗口。我们可以创建自己的线程，并通过 Handler 的 post 或 sendMessage 方法与应用程序主线程进行通信，然后 Message 将在 Handler 的 MessageQueue 中进行调度，并在适当的时候进行处理。 要使用 Handler，首先要获取到 Handler 的实例，因为它没有提供静态的创建实例的方法，所以我们只能通过它的构造方法创建。Handler 提供了很多构造方法，主要分为两大类： 第一类构造方法12345678910111213141516171819202122232425262728293031public Handler() &#123; this(null, false);&#125;public Handler(Callback callback) &#123; this(callback, false);&#125;public Handler(boolean async) &#123; this(null, async);&#125;public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; // 匿名类、内部类或本地类都必须申明为static，否则会警告可能出现内存泄露 final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 第一类构造方法，都是默认使用当前线程的 Looper 与 Handler 相关联，并且可以设置回调和是否为异步。Ok，既然有了构造方法，我们就可以使用它了。于是我们就这样创建一个 Handler 对象。 123456789public class SampleActivity extends Activity &#123; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; // ... &#125; &#125;&#125; 没问题吧，但是会发现 Android Studio 会发出如下警告： This Handler class should be static or leaks might occur (anonymous android.os.Handler).Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected. If the Handler is using a Looper or MessageQueue for a thread other than the main thread, then there is no issue. If the Handler is using the Looper or MessageQueue of the main thread, you need to fix your Handler declaration, as follows: Declare the Handler as a static class; In the outer class, instantiate a WeakReference to the outer class and pass this object to your Handler when you instantiate the Handler; Make all references to members of the outer class using the WeakReference object. 巴拉巴拉一大堆，其实就是告诉我们这样创建 Handler 可能会发生内存泄漏。因为在 Java 中，非静态内部类或匿名类会持有其外部类的引用，导致即使外部类不再使用也不能被垃圾回收机制回收。如果 Handler 是在非主线程中使用 Looper 或 MessageQueue，则没有问题（不明白为什么，虽然非主线程的 Loop 在 MessageQueue 中没有消息后就会退出 loop() 方法，但消息没有处理的时候还是会持有 Activity 的引用啊）。如果 Handler 在使用主线程（主线程的 loop() 方法不会退出）的 Looper 或 MessageQueue，则需要将 Handler 声明为静态类; 在外部类中，实例化 WeakReference 到外部类，并在实例化 Handler 时将此对象传递给Handler; 使用WeakReference对象来引用外部类的所有成员。 我们再来捋一遍发生内存泄漏的原因：我们发送的 Message 对象持有 Activity 中的 Handler 的引用，Handler 又隐式的持有它的外部类(也就是 Activity )的引用。而这个引用会一直存在，直到这个消息被处理，所以垃圾回收机制就没法回收这个 Activity，内存泄露就发生了。 因此创建 Handler 的正确姿势如下： 1234567891011121314151617181920212223242526public class SampleActivity extends Activity &#123; private static class MyHandler extends Handler &#123; private WeakReference&lt;SampleActivity&gt; activityWeakReference; private MyHandler(SampleActivity activity) &#123; activityWeakReference = new WeakReference&lt;&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); SampleActivity sampleActivity = activityWeakReference.get(); if (sampleActivity != null) &#123; sampleActivity.handleMessage(msg); &#125; &#125; &#125; private MyHandler mHandler = new MyHandler(SampleActivity.this); private void handlerMessage(Message msg) &#123; // 处理消息 &#125;&#125; 第二类构造方法1234567891011121314public Handler(Looper looper) &#123; this(looper, null, false);&#125;public Handler(Looper looper, Callback callback) &#123; this(looper, callback, false);&#125;public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 第二类构造方法可以设置指定的 Looper 与 Handler 相关联，当然同样可以设置回调和是否为异步。 现在我们已经创建了 Handler 的实例，接下来就可以用它来发送消息了。 Handler 发送消息主要分为两大类： Message 类型的消息 Runnable 类型的消息（最终还是转换为 Message 类型的消息） sendMessage1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public final boolean sendEmptyMessage(int what)&#123; return sendEmptyMessageDelayed(what, 0);&#125;public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;public final boolean sendMessageAtFrontOfQueue(Message msg) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, 0);&#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 对比上面几个方法后可以发现无论是以何种方式发送消息，最终都是调用 enqueueMessage() 方法将 Message 保存到当前 Handler 的 MessageQueue 中。 那么 post() 方法呢？ post()1234567891011121314151617181920212223242526272829303132public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;public final boolean postAtTime(Runnable r, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r), uptimeMillis);&#125;public final boolean postAtTime(Runnable r, Object token, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r, token), uptimeMillis);&#125;public final boolean postDelayed(Runnable r, long delayMillis)&#123; return sendMessageDelayed(getPostMessage(r), delayMillis);&#125;public final boolean postAtFrontOfQueue(Runnable r)&#123; return sendMessageAtFrontOfQueue(getPostMessage(r));&#125;private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125;private static Message getPostMessage(Runnable r, Object token)&#123; Message m = Message.obtain(); m.obj = token; m.callback = r; return m;&#125; 我们也可以看到，只是将 runnable 作为 message.callback，其实还是先调用与之对应的 senMessageXXX()方法，最终调用 enqueueMessage() 方法。 dispatchMessage消息发送后，会进入当前 Handler 的 MessageQueue 中，而 Handler 持有的 MessageQueue 其实就是与当前线程相关联的 Looper 持有的 MessageQueue，Looper 的 loop() 方法，会不断的从 MessageQueue 中取出消息进行分发，这个分发机制就是通过调用 Message 中的 target (其实就是Handler) 的 dispatchMessage() 方法实现的。 Looper.java 12345public static void loop() &#123; ... msg.target.dispatchMessage(msg); ...&#125; Message.java 1/*package*/ Handler target; Handler.java 1234private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; ...&#125; 通过上面几段代码可以看出，msg.target 就是一个 Handler 对象，而这个 target 是在 enqueueMessage() 方法中被赋值的，而且这个值就是 Handler 实例本身。下面就可以看 Handler 的 dispatchMessage() 方法了。 Handler.java 12345678910111213141516public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; // 如果 message 设置了 callback，也就是 runnable 消息，调用 callback.run()方法。 // 源代码为 handleCallback(msg)；实际上 handleCallback(msg) 的具体实现就是下面这行代码。 msg.callback.run(); &#125; else &#123; // 如果 handler 设置了 callback，执行 callback 回调。 if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; // 这个方法默认是空的，需要重写该方法来处理消息。 handleMessage(msg); &#125;&#125; 从 dispatchMessage 发放中，还可以看出消息分发是有三个级别的： Message 的回调方法 callback 不为空时，则回调方法 msg.callback.run() Handler 的 mCallback 成员变量不为空时，则回调方法 mCallback.handleMessage(msg) Handler 自身的回调方法 handleMessage()，该方法默认为空，我们可以通过重写该方法来完成具体的逻辑。 现在消息也已经发送了，剩下的就交给 Looper 来处理了。 Looper Looper 是用于一个线程运行消息循环的类。每个线程默认情况下没有与它相关联的消息循环，可以通过调用 Looper.prepare() 方法创建，创建完成后调用Lopper.loop()方法开始循环处理消息。 Looper.prepare()上面已经提过了，可以通过调用 Looper.prepare() 方法创建 Looper 的实例与一个线程相关联，那就先看看这个方法。 Looper提供了两个prepare()方法： 12345678910public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 我们只能调用无参的 prepare()方法（有参的方法是私有的），而且无参的方法内部也是调用有参的方法，并传入参数 true，表示允许退出，false 表示不允许退出。而直接调用这个私有的构造方法，并传入 false 的地方只有一个，那主是 prepareMainLooper() 方法： 123456789101112131415/** * Initialize the current thread as a looper, marking it as an * application's main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself. See also: &#123;@link #prepare()&#125; */public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125;&#125; 从注释中也可以看出，这个方法是创建 Application 的主 Looper，由Android系统调用（ActivityThread.main()和SystemServer.run()），我们不能调用这个方法。 ThreadLocal再回到prepare()方法，第一行中的 sThreadLocal 是什么？ 123456789// sThreadLocal.get() will return null unless you've called prepare().static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 可以看到 sThreadLocal 是一个 ThreadLocal 类型的静态变量。 什么是 ThreadLocal 呢? ThreadLocal 是一个用于创建线程局部变量的类。 线程局部变量又是什么呢？ 通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用 ThreadLocal 创建的变量只能被当前线程访问，其他线程则无法访问和修改，这就是线程局部变量。 ThreadLocal的特点： Global：在当前线程中，任何地方都可以访问到 ThreadLocal 的值。 Local：该线程的 ThreadLocal 的值只能被该线程自己访问和修改，一般情况下 其他线程访问不到。 下面是通过在主线程中创建 ThreadLocal 实例并为其赋值，然后测试子线程能否成功访问的示例： 1234567891011121314public static void main(String[] args) &#123; final ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); threadLocal.set("hello"); String s = threadLocal.get(); System.out.printf("当前线程 %s %s\n", Thread.currentThread().getName(), s); new Thread() &#123; @Override public void run() &#123; super.run(); String s = threadLocal.get(); System.out.printf("当前线程 %s %s\n", Thread.currentThread().getName(), s); &#125; &#125;.start();&#125; 打印结果： 12当前线程 main hello当前线程 Thread-0 null 从上面的输出可以证明：在主线程创建的 ThreadLocal 可以在主线程中获取到它的值，而在子线程中，就不能获取到了。 上面说一般情况下 ThreadLocal 的值只能被当前线程访问，那么当然就存在特殊情况了，我们可以使用 ThreadLocal 的子类 InheritableThreadLocal 实现在子线程中访问主线程中创建的值。 12345678910final ThreadLocal&lt;String&gt; threadLocal = new InheritableThreadLocal&lt;&gt;();threadLocal.set("hello");System.out.printf("当前线程 %s %s\n", Thread.currentThread().getName(), threadLocal.get());new Thread() &#123; @Override public void run() &#123; super.run(); System.out.printf("当前线程 %s %s\n", Thread.currentThread().getName(), threadLocal.get()); &#125;&#125;.start(); 打印结果： 12当前线程 main hello当前线程 Thread-0 hello 结果确实是主线程和子线程都可以访问。 ThreadLocal 怎样实现线程局部变量我们使用 ThreadLocal 的目的就是通过它的线程局部变量这个特性，保证数据不能被其他线程访问和修改。 这里既然关系到数据的访问与修改，那么必然就联系到了 ThreadLocal 内部的 set() 和 get() 方法了。 ThreadLocal.java 12345678910111213141516171819202122232425262728293031323334353637383940/** * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;/** * Returns the value in the current thread's copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread's value of this thread-local */public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue();&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; Thread.java 1234/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 通过 set() 和 get() 方法的前两行代码，可以看到它们都是首先获取当前线程的实例，然后再获取当前线程的 threadLocals 属性，最后才去对这个 threadLocals 进行赋值或取值操作。这样就保证了每个线程操作的只是它自己的 threadLocals，从而实现线程局部变量的效果。 Looper 的构造方法现在已经明白了 ThreadLocal 的实现原理，再次回到 prepare() 方法。 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 当我们第一次调用 sThreadLocal.get() 方法时，得到的肯定是 null，所以就向 sThreadLocal 中赋值一个 Looper 对象。 下面看一下 Looper 的构造方法： 1234567final MessageQueue mQueue;final Thread mThread;private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 在构造方法中可以看到，分别为 mQueue 和 mThread 赋值，而且 quitAllowed 也传递给 MessageQueue 的构造方法，还记得前面在 MessageQueue 中已经介绍过了吗？而且我们创建的 MessageQueue 都是必须退出的，只有主线程才不可以也不能退出。 其实 Looper 只有这一个私有的构造方法，这再一次证明我们不能直接创建 Looper 的实例，而是应该通过调用 Looper.prepare() 方法创建。 到此为止，我们通过调用 Looper.prepare() 方法已经创建了一个与当前线程绑定，并通过 ThreadLocal 保证每个线程只有一个的 Looper 实例，同时这个 Looper 实例持有一个 MessageQueue 对象实例。 Looper.loop()现在有了 MessageQueue 的实例，我们就可以调用 Looper.loop() 循环处理消息了。 下面是精简过的 loop() 方法： 123456789101112131415161718192021222324252627282930/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; msg.recycleUnchecked(); &#125;&#125;public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 首先从 sThreadLocal 中获取当前线程唯一的 Looper 实例 me，然后得到这个 Looper 实例的 MessageQueue 实例，接着就开始无限循环处理消息了。每当得到一个 Message 实例，只要不为空就调用 msg.target.dispatchMessage(msg) 开始分发消息。 总结 创建一个 Message 的正确方式是：Message.obtain() 或 Handler.obtain() 创建 Handler 时要注意避免内存泄漏 Looper 的 prepare() 方法，将 Looper 实例与当前线程绑定，通过 ThreadLocal 保证每个线程只有一个 Looper 实例，同时一个 Looper 实例也只有一个 MessageQueue 实例. Looper 的 loop() 方法，不断从 MessageQueue 中取出 message 对象，并调用 message.target.dispatchMessage() 方法分发处理。 附如果上面的内容都理解了，就通过下面这个问题检测一下吧！ 我们平时都是使用 Handler 在子线程发送消息、主线程中接收与处理消息，那么 Handler 可以在主线程中发送消息，在子线程中接收与处理消息吗？如果可以怎么实现呢？ 答案是可以的。因为我们通过 Handler 发送的 Message，都会保存到与它相关联的 Looper 的 MessageQueue 中，Looper 的 loop() 方法会不断循环取出 MessageQueue 中的 Message 并调用 message.target.dispatchMessage() 方法进行分发处理。 还记得 Handler 怎么与 Looper 关联，Looper 又是怎样与线程关联的吗？再来回顾一下。 Handler 除了可以与创建它的线程相关联的 Looper 相关联外，还可以与指定的 Looper 相关联，因此我们可以直接指定子线程的Looper 与 Handler 关联。但是，因为每个线程默认情况下没有与它相关联的 Looper，所以需要在子线程中先调用 Looper.prepare() 方法将 Looper 与子线程关联，创建完成后就可以调用Lopper.loop()方法开始循环处理消息了。 下面是详细代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class SampleActivity extends Activity &#123; private static class MyThread extends Thread &#123; private WeakReference&lt;SampleActivity&gt; activityWeakReference; private MyHandler mHandler; private MyThread(SampleActivity activity) &#123; activityWeakReference = new WeakReference&lt;&gt;(activity); &#125; @Override public void run() &#123; super.run(); Looper.prepare(); SampleActivity sampleActivity = activityWeakReference.get(); if (sampleActivity != null) &#123; mHandler = new MyHandler(sampleActivity); &#125; Looper.loop(); &#125; &#125; private static class MyHandler extends Handler &#123; private WeakReference&lt;SampleActivity&gt; activityWeakReference; private MyHandler(SampleActivity activity) &#123; activityWeakReference = new WeakReference&lt;&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); SampleActivity sampleActivity = activityWeakReference.get(); if (sampleActivity != null) &#123; sampleActivity.handleMessage(msg); &#125; &#125; &#125; private void handleMessage(Message message) &#123; Log.e("handlerMessage", "currentThread:" + Thread.currentThread().getName() + "message.what:" + message.what); &#125; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.e("onCreate", "currentThread:" + Thread.currentThread().getName()); // 创建子线程 final MyThread myThread = new MyThread(this); // 开启子线程接收消息 myThread.start(); // 创建一个发送消息的线程 new Thread() &#123; @Override public void run() &#123; super.run(); while (true) &#123; SystemClock.sleep(3000); myThread.mHandler.sendEmptyMessage(new Random().nextInt(10)); &#125; &#125; &#125;.start(); &#125;&#125; 打印结果： 1234567891011E/onCreate: currentThread:mainE/handleMessage: currentThread:Thread-9430,message.what:9E/handleMessage: currentThread:Thread-9430,message.what:2E/handleMessage: currentThread:Thread-9430,message.what:7E/handleMessage: currentThread:Thread-9430,message.what:7E/handleMessage: currentThread:Thread-9430,message.what:9E/handleMessage: currentThread:Thread-9430,message.what:3E/handleMessage: currentThread:Thread-9430,message.what:5E/handleMessage: currentThread:Thread-9430,message.what:2E/handleMessage: currentThread:Thread-9430,message.what:3E/handleMessage: currentThread:Thread-9430,message.what:6 很明显可以看出消息是在子线程中接收与处理的。 延伸再来一个问题，Android 中什么情况下会在子线程中发送消息和处理消息呢？ 当然是耗时操作，而耗时操作又使用什么来实现呢？ Service，其实 IntentService 就是利用 Handler 机制实现的。 查看IntentService 的使用与源码解析]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FragmentManager is already executing transactions 异常分析]]></title>
    <url>%2Fposts%2F7b4d3187.html</url>
    <content type="text"><![CDATA[今天是 2019年09月13日，农历八月十五。没错今天是中秋节，而且对我来说，今年的中秋不一样🖕。 故事是这样的 —— 中秋前一天的晚上线上发现了问题，在家改bug到后半夜。中秋当天上午早上又接到线上的问题反馈，于是在家与其他几个小伙伴一起连线排查解决。经过一上午的努力，修改了几个问题，但是有两个问题没有查到原因和解决办法，于是决定下午去公司解决，还好下午狠顺利的将问题复现了，并找到了原因和解决办法。当把问题都回归验证后，已经是快晚上7点钟了。回到家不到 8 点，吃了一大碗大家下午包的给我一个人留得饺子…… 扯蛋完毕，现在回到正题。 需求用户按返回键即将退出当前页面前，需要立即请求接口判断是否显示一个 Dialog，如果展示 Dialog 则不退出页面，否则再退出页面。 模拟代码1234567891011121314151617181920212223class MainActivity : AppCompatActivity() &#123; override fun onBackPressed() &#123; sendRequest().observe(this@MainActivity, Observer &#123; if (it == true) &#123; Toast.makeText(this@MainActivity, "弹出Dialog", Toast.LENGTH_SHORT).show() &#125; else &#123; super.onBackPressed() &#125; &#125;) &#125; private fun sendRequest(): LiveData&lt;Boolean&gt; &#123; val result = MutableLiveData&lt;Boolean&gt;() // 这里假设请求用时 500 ms。 Handler().postDelayed(&#123; result.postValue(false) &#125;, 500L) return result &#125;&#125; 问题正常情况下，一个请求几百毫秒内就可以完成，但是如果在弱网环境下，当用户点击返回键后，由于长时间没有反应，此时可能用户着急了，于是按下 Home 键，应用进入后台。一段时间后网络请求成功（返回结果为不显示 Dialog）或请求超时，用户再次返回应用时，此时发生如下异常： Android 8.0（不包含8.0） 以下 ANR。 Android 8.0+ 报以下错误， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051522019-09-13 21:39:05.780 2106-2106/com.xiaomai E/AndroidRuntime: FATAL EXCEPTION: main Process: com.xiaomai, PID: 2106 java.lang.RuntimeException: Unable to resume activity &#123;com.xiaomai/com.xiaomai.MainActivity&#125;: java.lang.IllegalStateException: FragmentManager is already executing transactions at android.app.ActivityThread.performResumeActivity(ActivityThread.java:3645) at android.app.ActivityThread.handleResumeActivity(ActivityThread.java:3685) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1643) at android.os.Handler.dispatchMessage(Handler.java:105) at android.os.Looper.loop(Looper.java:164) at android.app.ActivityThread.main(ActivityThread.java:6541) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:767) Caused by: java.lang.IllegalStateException: FragmentManager is already executing transactions at android.app.FragmentManagerImpl.ensureExecReady(FragmentManager.java:1987) at android.app.FragmentManagerImpl.execPendingActions(FragmentManager.java:2043) at android.app.FragmentManagerImpl.popBackStackImmediate(FragmentManager.java:850) at android.app.FragmentManagerImpl.popBackStackImmediate(FragmentManager.java:811) at android.app.Activity.onBackPressed(Activity.java:2993) at androidx.fragment.app.FragmentActivity.onBackPressed(FragmentActivity.java:191) at com.xiaomai.MainActivity.access$onBackPressed$s1136912392(MainActivity.kt:14) at com.xiaomai.MainActivity$onBackPressed$1.onChanged(MainActivity.kt:28) at com.xiaomai.MainActivity$onBackPressed$1.onChanged(MainActivity.kt:14) at androidx.lifecycle.LiveData.considerNotify(LiveData.java:131) at androidx.lifecycle.LiveData.dispatchingValue(LiveData.java:144) at androidx.lifecycle.LiveData$ObserverWrapper.activeStateChanged(LiveData.java:442) at androidx.lifecycle.LiveData$LifecycleBoundObserver.onStateChanged(LiveData.java:394) at androidx.lifecycle.LifecycleRegistry$ObserverWithState.dispatchEvent(LifecycleRegistry.java:361) at androidx.lifecycle.LifecycleRegistry.forwardPass(LifecycleRegistry.java:300) at androidx.lifecycle.LifecycleRegistry.sync(LifecycleRegistry.java:339) at androidx.lifecycle.LifecycleRegistry.moveToState(LifecycleRegistry.java:145) at androidx.lifecycle.LifecycleRegistry.handleLifecycleEvent(LifecycleRegistry.java:131) at androidx.lifecycle.ReportFragment.dispatch(ReportFragment.java:123) at androidx.lifecycle.ReportFragment.onStart(ReportFragment.java:83) at android.app.Fragment.performStart(Fragment.java:2637) at android.app.FragmentManagerImpl.moveToState(FragmentManager.java:1312) at android.app.FragmentManagerImpl.moveFragmentToExpectedState(FragmentManager.java:1549) at android.app.FragmentManagerImpl.moveToState(FragmentManager.java:1611) at android.app.FragmentManagerImpl.dispatchMoveToState(FragmentManager.java:3039) at android.app.FragmentManagerImpl.dispatchStart(FragmentManager.java:2996) at android.app.FragmentController.dispatchStart(FragmentController.java:189) at android.app.Activity.performStart(Activity.java:6998) at android.app.Activity.performRestart(Activity.java:7066) at android.app.Activity.performResume(Activity.java:7071) at android.app.ActivityThread.performResumeActivity(ActivityThread.java:3620) at android.app.ActivityThread.handleResumeActivity(ActivityThread.java:3685) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1643) at android.os.Handler.dispatchMessage(Handler.java:105) at android.os.Looper.loop(Looper.java:164) at android.app.ActivityThread.main(ActivityThread.java:6541) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:767) 问题重现为了模拟弱网环境，方便问题重现，这里把请求时间改为 3s。 123Handler().postDelayed(&#123; result.postValue(false)&#125;, 3000L) 当按下返回键后，立即按 Home 键，等待 3 秒后再次回到应用，问题重现。 原因排查从堆栈的异常日志可以看到：异常发生的原因与 Fragment 有关，并且对 Fragment 进行了不正当的操作。 看一下代码中哪个地方用到了 Fragment 呢？仔细一行行的看过代码后，发现没有地方使用 Fragment！！！ WHAT????? 这是为什么呢？代码中没有任何地方使用 Fragment，错误堆栈中却报了与 Fragment 有关的信息，再仔细看一下堆栈的异常日志，发现有一个叫 ReportFragment 的类。 原来，ReportFragment 是 Android 为了实现 Lifecycles 相关功能而自动添加的。 接下来，调试一下当应用从后台返回时都发生了什么？ 1234567handleResumeActivity:3685, ActivityThread (android.app)performResumeActivity:3620, ActivityThread (android.app)performResume:7071, Activity (android.app)performRestart:7066, Activity (android.app)performStart:6991, Activity (android.app)execPendingActions:402, FragmentController (android.app)execPendingActions:2043, FragmentManagerImpl (android.app) =&gt; 代码分析一 代码分析一（此时的 FragmentManager 为 Activity 中的 FragmentManager）： 12345678public boolean execPendingActions() &#123; ensureExecReady(true); boolean didSomething = false; ...省略部分代码 return didSomething;&#125; 代码分析二（此时 FragmentManager 仍为 Activity 中的）： 123456789101112131415161718private void ensureExecReady(boolean allowStateLoss) &#123; if (mExecutingActions) &#123; // 这正是堆栈日志中抛出的异常信息 throw new IllegalStateException("FragmentManager is already executing transactions"); &#125; if (Looper.myLooper() != mHost.getHandler().getLooper()) &#123; throw new IllegalStateException("Must be called from main thread of fragment host"); &#125; ... 省略部分代码 mExecutingActions = true; try &#123; executePostponedTransaction(null, null); &#125; finally &#123; mExecutingActions = false; &#125;&#125; 虽然这里找到了异常信息，但是这时并没有抛出异常。 接下来的运行如下： 123dispatchStart:189, FragmentController (android.app)dispatchStart:2996, FragmentManagerImpl (android.app)dispatchMoveToState:3039, FragmentManagerImpl (android.app) =&gt; 代码分析三 代码分析三（此时 FragmentManager 仍为 Activity 中的）： 1234567891011121314private void dispatchMoveToState(int state) &#123; if (mAllowOldReentrantBehavior) &#123; moveToState(state, false); &#125; else &#123; try &#123; mExecutingActions = true; // 见代码分析四 moveToState(state, false); &#125; finally &#123; mExecutingActions = false; &#125; &#125; execPendingActions();&#125; 这里要注意的是 mExecutingActions = true;然后就进入了 moveToState 方法。 代码分析四（此时 FragmentManager 仍为 Activity 中的）： 12345678910111213141516void moveToState(int newState, boolean always) &#123; ... 省略部分代码 // Now iterate through all active fragments. These will include those that are removed // and detached. final int numActive = mActive.size(); for (int i = 0; i &lt; numActive; i++) &#123; // 此时 mActivie 中只有一个且为 ReportFragment Fragment f = mActive.valueAt(i); if (f != null &amp;&amp; (f.mRemoving || f.mDetached) &amp;&amp; !f.mIsNewlyAdded) &#123; // 见代码分析五 moveFragmentToExpectedState(f); ... &#125; &#125; ... 省略部分代码&#125; 代码分析五（此时 FragmentManager 为 Activity 中的）： 1234567891011121314151617181920void moveFragmentToExpectedState(final Fragment f) &#123; ... moveToState(f, nextState, f.getNextTransition(), f.getNextTransitionStyle(), false); ...&#125;@SuppressWarnings("ReferenceEquality")void moveToState(Fragment f, int newState, int transit, int transitionStyle, boolean keepActive) &#123; ... switch (f.mState) &#123; case Fragment.STOPPED: if (newState &gt; Fragment.STOPPED) &#123; // 见代码分析六 f.performStart(); dispatchOnFragmentStarted(f, false); &#125; ... &#125; ...&#125; 代码分析六（此时进入 Fragment）： 1234567891011public class Fragment &#123; void performStart() &#123; if (mChildFragmentManager != null) &#123; mChildFragmentManager.noteStateNotSaved(); // 再次回到代码分析一 mChildFragmentManager.execPendingActions(); &#125; ... &#125;&#125; 虽然这里再次进入代码分析一，但这时的 FragmentManager 与前面的 FragmentManager 已经不是同一个了，之前是 Activity 中的而现在是 ReportFragment 中的 childFragmentManager，并且 Activity 的栈帧仍然处在代码分析三的 mo veToState() 方法中，mExecutingActions 仍然为 true。 代码分析一（此时的 FragmentManager 为 ReportFragment 中的 childFragmentManager）： 12345678public boolean execPendingActions() &#123; ensureExecReady(true); boolean didSomething = false; ...省略部分代码 return didSomething;&#125; 代码分析二（此时的 FragmentManager 为 ReportFragment 中的 childFragmentManager）： 123456789101112131415161718private void ensureExecReady(boolean allowStateLoss) &#123; if (mExecutingActions) &#123; // 这正是堆栈日志中抛出的异常信息 throw new IllegalStateException("FragmentManager is already executing transactions"); &#125; if (Looper.myLooper() != mHost.getHandler().getLooper()) &#123; throw new IllegalStateException("Must be called from main thread of fragment host"); &#125; ... 省略部分代码 mExecutingActions = true; try &#123; executePostponedTransaction(null, null); &#125; finally &#123; mExecutingActions = false; &#125;&#125; 这时仍然没有抛出异常。 接下来的运行仍然如下： 123dispatchStart:189, FragmentController (android.app)dispatchStart:2996, FragmentManagerImpl (android.app)dispatchMoveToState:3039, FragmentManagerImpl (android.app) =&gt; 代码分析三 代码分析三（此时的 FragmentManager 为 ReportFragment 中的 childFragmentManager）： 1234567891011121314private void dispatchMoveToState(int state) &#123; if (mAllowOldReentrantBehavior) &#123; moveToState(state, false); &#125; else &#123; try &#123; mExecutingActions = true; // 见代码分析四 moveToState(state, false); &#125; finally &#123; mExecutingActions = false; &#125; &#125; execPendingActions();&#125; 这里仍然要注意的是 mExecutingActions = true;然后就进入了 moveToState 方法。 代码分析四（此时的 FragmentManager 为 ReportFragment 中的 childFragmentManager）： 12345678910111213141516void moveToState(int newState, boolean always) &#123; ... 省略部分代码 // Now iterate through all active fragments. These will include those that are removed // and detached. final int numActive = mActive.size(); // 这时 numActive = 0，所以不会进入 for 循环。 for (int i = 0; i &lt; numActive; i++) &#123; Fragment f = mActive.valueAt(i); if (f != null &amp;&amp; (f.mRemoving || f.mDetached) &amp;&amp; !f.mIsNewlyAdded) &#123; moveFragmentToExpectedState(f); ... &#125; &#125; ... 省略部分代码&#125; 因为这里不会进入 for 循环，所以方法运行结束后，会进入代码分析三中 finally 代码块中，将 mExecutingActions 赋值为 false;这时方法执行完毕，回到代码分析六，继续向下执行： 12345678910111213public class Fragment &#123; void performStart() &#123; if (mChildFragmentManager != null) &#123; mChildFragmentManager.noteStateNotSaved(); mChildFragmentManager.execPendingActions(); // 执行完毕 &#125; mState = STARTED; mCalled = false; // 见代码分析七 onStart(); &#125;&#125; 代码分析七： 12345678public class ReportFragment extends Fragment &#123; @Override public void onStart() &#123; super.onStart(); dispatchStart(mProcessListener); dispatch(Lifecycle.Event.ON_START); &#125;&#125; 在 ReportFragment 的 onStart() 方法，会对 OnStart 事件进行分发，之后 LiveData 在 MainActivity 中等到响应： 12345678910override fun onBackPressed() &#123; sendRequest().observe(this@MainActivity, Observer &#123; if (it == true) &#123; // 因为返回的结果是 true，所以执行此方法。见代码分析八 super.onBackPressed() &#125; else &#123; Toast.makeText(this@MainActivity, "弹出Dialog", Toast.LENGTH_SHORT).show() &#125; &#125;)&#125; 代码分析八： 123456789101112131415161718public class FragmentActivity &#123; public void onBackPressed() &#123; // 这时的 fragmentManger 又是一个新的 FragmentManger，它属于 FragmentActivity。 FragmentManager fragmentManager = mFragments.getSupportFragmentManager(); final boolean isStateSaved = fragmentManager.isStateSaved(); if (isStateSaved &amp;&amp; Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.N_MR1) &#123; // Older versions will throw an exception from the framework // FragmentManager.popBackStackImmediate(), so we'll just // return here. The Activity is likely already on its way out // since the fragmentManager has already been saved. return; &#125; if (isStateSaved || !fragmentManager.popBackStackImmediate()) &#123; // 代码分析九 super.onBackPressed(); &#125; &#125;&#125; 代码分析九： 123456789101112131415public class Activity &#123; public void onBackPressed() &#123; if (mActionBar != null &amp;&amp; mActionBar.collapseActionView()) &#123; return; &#125; // 这个 fragmentManager 又变成了 Activity 中的 FragmentManager。 FragmentManager fragmentManager = mFragments.getFragmentManager(); // 见代码分析十 if (fragmentManager.isStateSaved() || !fragmentManager.popBackStackImmediate()) &#123; finishAfterTransition(); &#125; &#125;&#125; 代码分析十（此时的 FragmentManager 为 Activity 中的 FragmentManager）： 1234567891011121314@Overridepublic boolean popBackStackImmediate() &#123; checkStateLoss(); return popBackStackImmediate(null, -1, 0);&#125;private boolean popBackStackImmediate(String name, int id, int flags) &#123; // 再次进入代码分析一，此时的 fragmentManager 与第一次分析中的是同一个 execPendingActions(); ensureExecReady(true); ... 省略部分代码 return executePop;&#125; 我们再次进入到代码分析二中: 123456private void ensureExecReady(boolean allowStateLoss) &#123; if (mExecutingActions) &#123; // 这正是堆栈日志中抛出的异常信息 throw new IllegalStateException("FragmentManager is already executing transactions"); &#125;&#125; 因为前面在代码分析三中我们强调过，Activity 中的 mExecutingActions 为 true 后，就再也没有被修改为 false，所以这里抛出了异常。 至此，问题的原因已经找到了，是由于 Activity 中的 FragmentManager 的第一次任务还没有执行完毕，其他的操作又导致它需要进行第二次任务，所以发生错误。 解决方案问题的原因已经找到了，所以当第一次任务没有执行结束时，如果有第二个任务到来，我们可以从两个方面去解决问题： 直接丢弃第二个任务在页面不可见时，取消对 LiveData 的监听，这样页面重新可见时，就不会接收到变化的通知了，修改代码如下： 1234567891011121314151617181920212223242526272829303132class MainActivity : AppCompatActivity() &#123; private val observer = Observer&lt;Boolean&gt; &#123; if (it == true) &#123; super.onBackPressed() &#125; else &#123; Toast.makeText(this@MainActivity, "弹出Dialog", Toast.LENGTH_SHORT).show() &#125; &#125; private var result: LiveData&lt;Boolean&gt;? = null override fun onBackPressed() &#123; result = sendRequest() result?.observe(this@MainActivity, observer) &#125; override fun onStop() &#123; super.onStop() result?.removeObserver(observer) &#125; private fun sendRequest(): LiveData&lt;Boolean&gt; &#123; val result = MutableLiveData&lt;Boolean&gt;() Handler().postDelayed(&#123; result.postValue(true) &#125;, 3000L) return result &#125;&#125; 等待第一个任务执行完毕后再执行第二个任务通过 Handler.post() 方式，将任务滞后完成。 123456789101112131415161718192021222324class MainActivity : AppCompatActivity() &#123; override fun onBackPressed() &#123; sendRequest().observe(this@MainActivity, Observer &#123; if (it == true) &#123; Handler().post &#123; super.onBackPressed() &#125; &#125; else &#123; Toast.makeText(this@MainActivity, "弹出Dialog", Toast.LENGTH_SHORT).show() &#125; &#125;) &#125; private fun sendRequest(): LiveData&lt;Boolean&gt; &#123; val result = MutableLiveData&lt;Boolean&gt;() Handler().postDelayed(&#123; result.postValue(true) &#125;, 3000L) return result &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刘海屏适配]]></title>
    <url>%2Fposts%2Fdf0aa059.html</url>
    <content type="text"><![CDATA[关于刘海屏的适配方案有两种： 可以在刘海屏区域展示，即使部分内容被『吃掉』也没关系； 不可以在刘海屏区域展示，避免重要的信息不能被用户看到，影响使用。 本文针对这两种情况进行分析： 知识储备window.decorView.systemUiVisibility 的可选值（部分） View.SYSTEM_UI_FLAG_VISIBLE 默认标记。显示状态栏和导航栏，Activity 正常显示。 View.INVISIBLE 隐藏状态栏，同时Activity会伸展全屏显示。 View.SYSTEM_UI_FLAG_LOW_PROFILE 低调模式, 会隐藏不重要的状态栏图标 View.SYSTEM_UI_FLAG_LAYOUT_STABLE 保持整个View稳定, 常和控制System UI悬浮, 隐藏的Flags共用, 使View不会因为System UI的变化而重新layout View.SYSTEM_UI_FLAG_FULLSCREEN 状态栏隐藏，Activity全屏显示。效果同设置WindowManager.LayoutParams.FLAG_FULLSCREEN View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN 视图延伸至状态栏区域，状态栏上浮于视图之上 View.SYSTEM_UI_FLAG_HIDE_NAVIGATION 隐藏导航栏 View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION 视图延伸至导航栏区域，导航栏上浮于视图之上 View.SYSTEM_UI_FLAG_IMMERSIVE 沉浸模式, 隐藏状态栏和导航栏, 并且在第一次会弹泡提醒, 并且在状态栏区域滑动可以呼出状态栏（这样会清除之前设置的View.SYSTEM_UI_FLAG_FULLSCREEN 或 View.SYSTEM_UI_FLAG_HIDE_NAVIGATION标志）。使之生效，需要和 View.SYSTEM_UI_FLAG_FULLSCREEN，View.SYSTEM_UI_FLAG_HIDE_NAVIGATION 中的一个或两个同时设置。 View.SYSTEM_UI_FLAG_IMMERSIVE_STIKY 与上面唯一的区别是, 呼出隐藏的状态栏后不会清除之前设置的View.SYSTEM_UI_FLAG_FULLSCREEN或View.SYSTEM_UI_FLAG_HIDE_NAVIGATION标志，在一段时间后将再次隐藏系统栏）。 layoutInDisplayCutoutMode（Android P 提供） 模式 模式说明 LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT 只有当DisplayCutout完全包含在系统栏中时，才允许窗口延伸到DisplayCutout区域。 否则，窗口布局不与DisplayCutout区域重叠。 LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER 该窗口决不允许与DisplayCutout区域重叠。 LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES 该窗口始终允许延伸到屏幕短边上的DisplayCutout区域。 在刘海屏区域内展示内容，部分内容被『吃掉』不影响效果如下： 这种方案比较好适配，如果是 Android 9.0 及以上系统，使用官方提供的方案，否则设置布局延伸到状态栏即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.xiaomai.demoimport android.graphics.Colorimport android.os.Buildimport android.os.Bundleimport android.support.v7.app.AppCompatActivityimport android.view.Viewimport android.view.WindowManagerimport kotlinx.android.synthetic.main.full_screen.*class FullActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.full_screen) showTitleBar() // 如果系统版本大于等于 Android 9.0，系统支持刘海屏, 否则部分国产手机可能在 Android 8.0 就支持了刘海屏，需要在 manifest 中配置。 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123; window.attributes = window.attributes.apply &#123; layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES &#125; &#125; var isShow = true touchView.setOnClickListener &#123; isShow = !isShow if (isShow) &#123; showTitleBar() &#125; else &#123; hideTitleBar() &#125; &#125; &#125; private fun showTitleBar() &#123; // 设置状态栏透明 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; window.statusBarColor = Color.TRANSPARENT &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION or // 视图延伸至导航栏区域，导航栏上浮于视图之上 View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN // 视图延伸至状态栏区域，状态栏上浮于视图之上 &#125; &#125; /** * 已知问题，在 Vivo X21A 全屏适配有问题 */ private fun hideTitleBar() &#123; var options = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION // 隐藏导航栏 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; options = options or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION or // 视图延伸至导航栏区域，导航栏上浮于视图之上 View.SYSTEM_UI_FLAG_FULLSCREEN or // 隐藏状态栏 View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN // 视图延伸至状态栏区域，状态栏上浮于视图之上 &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; options = options or View.SYSTEM_UI_FLAG_IMMERSIVE // 沉浸模式, 隐藏状态栏和导航栏, 并且在第一次会弹泡提醒, 并且在状态栏区域滑动可以呼出状态栏 &#125; window.decorView.systemUiVisibility = options &#125;&#125; 内容重要，不能在刘海屏区域展示 思路：首先检查设备是否是刘海屏，如果是的话则设置不在状态栏显示内容，如果不是话则可以在状态栏显示。 检测设备是否是刘海屏的思路： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113class FullActivity : AppCompatActivity() &#123; private val TAG = "FullActivity" private var hasDisplayCutout = false set(value) &#123; field = value if (value) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123; window.attributes = window.attributes.apply &#123; layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER &#125; &#125; // 设置状态栏为黑色 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; window.statusBarColor = Color.BLACK &#125; &#125; else &#123; // 设置状态栏透明 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; window.statusBarColor = Color.TRANSPARENT &#125; &#125; showTitleBar() &#125; /** * 监查是否是刘海屏 */ private fun checkDisplayCutout() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123; val decorView = window.decorView decorView.post &#123; val displayCutout = decorView.rootWindowInsets.displayCutout displayCutout?.apply &#123; Log.e(TAG, "安全区域距离屏幕左边的距离 SafeInsetLeft:" + displayCutout.safeInsetLeft) Log.e(TAG, "安全区域距离屏幕右部的距离 SafeInsetRight:" + displayCutout.safeInsetRight) Log.e(TAG, "安全区域距离屏幕顶部的距离 SafeInsetTop:" + displayCutout.safeInsetTop) Log.e(TAG, "安全区域距离屏幕底部的距离 SafeInsetBottom:" + displayCutout.safeInsetBottom) &#125; hasDisplayCutout = displayCutout?.safeInsetTop ?: 0 &gt; 0 &#125; &#125; else &#123; hasDisplayCutout = DisplayCutoutUtils.isSupportDisplayCutout(this@FullActivity) &#125; &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.full_screen) checkDisplayCutout() var isShow = true touchView.setOnClickListener &#123; isShow = !isShow if (isShow) &#123; showTitleBar() &#125; else &#123; hideTitleBar() &#125; &#125; &#125; private fun showTitleBar() &#123; var newOptions = window.decorView.systemUiVisibility if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; newOptions = View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION &#125; if (hasDisplayCutout) &#123; // do nothing &#125; else &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; newOptions = newOptions or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN &#125; &#125; window.decorView.systemUiVisibility = newOptions &#125; private fun hideTitleBar() &#123; var newOptions = window.decorView.systemUiVisibility if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; newOptions = View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION &#125; if (hasDisplayCutout) &#123; // do nothing &#125; else &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; newOptions = (newOptions or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_FULLSCREEN) &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; newOptions = newOptions or View.SYSTEM_UI_FLAG_IMMERSIVE &#125; &#125; window.decorView.systemUiVisibility = newOptions &#125;&#125; 以下是通过反射获取 Android P 版本以下的设备是否是刘海屏的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146object DisplayCutoutUtils &#123; private const val TAG = "DisplayCutoutUtils" private fun Number.dp2Pixels() = TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_DIP, this.toFloat(), Resources.getSystem().displayMetrics ) fun isSupportDisplayCutout(context: Context): Boolean &#123; return getDisplayCutoutHeight(context) &gt; 0 &#125; //调用该方法，可以获取刘海屏的px值，没刘海屏则返回0 private fun getDisplayCutoutHeight(context: Context): Float &#123; var displayCutoutHeight = 0.0f //判断手机厂商，目前8.0只有华为、小米、oppo、vivo适配了刘海屏 val phoneManufacturer = Build.BRAND.toLowerCase(Locale.CHINESE) if ("huawei" == phoneManufacturer) &#123; //huawei,长度为length,单位px val haveDisplayCutoutEMUI = hasDisplayCutoutInEMUI(context) if (haveDisplayCutoutEMUI) &#123; val displayCutout: IntArray = getDisplayCutoutSizeInEMUI(context) displayCutoutHeight = displayCutout[1].toFloat() Log.e( TAG, "haveDisplayCutoutInEMUI: $haveDisplayCutoutEMUI, displayCutout: $displayCutout" ) &#125; &#125; else if ("xiaomi" == phoneManufacturer) &#123; //xiaomi,单位px val haveDisplayCutoutInMIUI = getDisplayCutoutInMIUI("ro.miui.notch", 0) == 1 if (haveDisplayCutoutInMIUI) &#123; val resourceId = context.resources.getIdentifier("notch_height", "dimen", "android") var result = 0 if (resourceId &gt; 0) &#123; result = context.resources.getDimensionPixelSize(resourceId) &#125; displayCutoutHeight = result.toFloat() Log.e( TAG, "haveDisplayCutoutInMIUI: $haveDisplayCutoutInMIUI, displayCutoutHeight: $displayCutoutHeight" ) &#125; &#125; else if ("vivo" == phoneManufacturer) &#123; //vivo,单位dp，高度27dp val haveDisplayCutoutInVIVO = hasDisplayCutoutInVivo(context) if (haveDisplayCutoutInVIVO) &#123; displayCutoutHeight = 27.dp2Pixels() Log.e( TAG, "haveDisplayCutoutInVIVO: $haveDisplayCutoutInVIVO, displayCutoutHeight: $displayCutoutHeight" ) &#125; &#125; else if ("oppo" == phoneManufacturer) &#123; //oppo val haveDisplayCutoutInOPPO = context.packageManager.hasSystemFeature("com.oppo.feature.screen.heteromorphism") if (haveDisplayCutoutInOPPO) &#123; displayCutoutHeight = 80f Log.e( TAG, "haveDisplayCutoutInOPPO: $haveDisplayCutoutInOPPO, displayCutoutHeight: $displayCutoutHeight" ) &#125; &#125; return displayCutoutHeight &#125; //huawei private fun hasDisplayCutoutInEMUI(context: Context): Boolean &#123; var ret = false try &#123; val cl = context.classLoader val hwNotchSizeUtilClass = cl.loadClass("com.huawei.android.util.HwNotchSizeUtil") val hasNotchInScreenMethod = hwNotchSizeUtilClass.getMethod("hasNotchInScreen") ret = hasNotchInScreenMethod.invoke(hwNotchSizeUtilClass) as Boolean &#125; catch (e: ClassNotFoundException) &#123; Log.e(TAG, "hasDisplayCutoutInEMUI ClassNotFoundException") &#125; catch (e: NoSuchMethodException) &#123; Log.e(TAG, "hasDisplayCutoutInEMUI NoSuchMethodException") &#125; catch (e: Exception) &#123; Log.e(TAG, "hasDisplayCutoutInEMUI Exception") &#125; finally &#123; return ret &#125; &#125; private fun getDisplayCutoutSizeInEMUI(context: Context): IntArray &#123; var ret = intArrayOf(0, 0) try &#123; val cl = context.classLoader val hwNotchSizeUtilClass = cl.loadClass("com.huawei.android.util.HwNotchSizeUtil") val getNotchSizeMethod = hwNotchSizeUtilClass.getMethod("getNotchSize") ret = getNotchSizeMethod.invoke(hwNotchSizeUtilClass) as IntArray &#125; catch (e: ClassNotFoundException) &#123; Log.e(TAG, "getDisplayCutoutSizeInEMUI ClassNotFoundException") &#125; catch (e: NoSuchMethodException) &#123; Log.e(TAG, "getDisplayCutoutSizeInEMUI NoSuchMethodException") &#125; catch (e: Exception) &#123; Log.e(TAG, "getDisplayCutoutSizeInEMUI Exception") &#125; finally &#123; return ret &#125; &#125; private fun getDisplayCutoutInMIUI(key: String, def: Int): Int &#123; var getIntMethod: Method? = null try &#123; if (getIntMethod == null) &#123; getIntMethod = Class.forName("android.os.SystemProperties") .getMethod("getInt", String::class.java, Int::class.javaPrimitiveType) &#125; return (getIntMethod?.invoke(null, key, def) as? Int)?.toInt() ?: 0 &#125; catch (e: Exception) &#123; Log.e(TAG, "Platform error: $e") return def &#125; &#125; private fun hasDisplayCutoutInVivo(context: Context): Boolean &#123; var ret = false try &#123; val classLoader = context.classLoader val ftFeatureClass = classLoader.loadClass("android.util.FtFeature") val isFeatureSupportMethod = ftFeatureClass.getMethod("isFeatureSupport", Int::class.javaPrimitiveType!!) ret = isFeatureSupportMethod.invoke(ftFeatureClass, 0x00000020) as Boolean &#125; catch (e: ClassNotFoundException) &#123; Log.e(TAG, "hasDisplayCutoutInVivo ClassNotFoundException") &#125; catch (e: NoSuchMethodException) &#123; Log.e(TAG, "hasDisplayCutoutInVivo NoSuchMethodException") &#125; catch (e: Exception) &#123; Log.e(TAG, "hasDisplayCutoutInVivo Exception") &#125; finally &#123; return ret &#125; &#125;&#125; 带虚拟导航的 Pad 设备有的 Pad 在横屏时，虚拟导航在屏幕右侧，而有的在屏幕下方。有两种计算屏幕宽高的方法，一种包含虚拟导航栏，一种不包含。 123456789101112131415161718192021222324252627282930313233fun getScreenHeight() = Resources.getSystem().displayMetrics.heightPixelsfun getScreenWidth() = Resources.getSystem().displayMetrics.widthPixels/** * 包含虚拟导航栏 */fun getRealScreenHeight(context: Context): Int &#123; return if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; val windowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager val display = windowManager.defaultDisplay val metrics = DisplayMetrics() display.getRealMetrics(metrics) metrics.heightPixels &#125; else &#123; getScreenHeight() &#125;&#125;/** * 包含虚拟导航栏 */fun getRealScreenWidth(context: Context): Int &#123; return if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; val windowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager val display = windowManager.defaultDisplay val metrics = DisplayMetrics() display.getRealMetrics(metrics) metrics.widthPixels &#125; else &#123; getScreenWidth() &#125;&#125; 参考链接 https://developer.android.com/guide/topics/display-cutout https://juejin.im/post/5b1930835188257d7541ba33 MIUI 开发文档 Vivo 开发文档]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>屏幕适配</tag>
        <tag>刘海屏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dialog 中监听键盘弹出与收起事件]]></title>
    <url>%2Fposts%2Fa5f0e43e.html</url>
    <content type="text"><![CDATA[最近遇到了一个在 Dialog 中监听键盘弹出与收起事件的需求，经过查询资料再与自己的需求相结合然后思考，最终解决了问题。现将中间遇到的问题与解决办法记录下来。 需求与效果 思路自定义 Dialog，通过设置 Dialog 的 “windowSoftInputMode” 配合监听 Dialog 所在 Window 的高度变化来判断键盘当前的状态。 实现布局1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/rootView" android:layout_width="match_parent" android:layout_height="44dp" android:layout_gravity="bottom" android:background="@android:color/white" android:orientation="horizontal"&gt; &lt;EditText android:id="@+id/editText" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_weight="1" android:background="@null" android:hint="点此参加讨论~" android:maxLines="1" android:paddingLeft="10dp" android:paddingRight="10dp" android:singleLine="true" android:textColor="@android:color/black" android:textSize="13sp" /&gt; &lt;TextView android:id="@+id/sendButton" android:layout_width="wrap_content" android:layout_height="match_parent" android:gravity="center" android:paddingLeft="15dp" android:paddingRight="15dp" android:text="发送" android:textColor="@android:color/black" android:textSize="13sp" /&gt;&lt;/LinearLayout&gt; style1234567&lt;style name="Dialog" parent="Theme.AppCompat.Dialog"&gt; &lt;item name="android:background"&gt;@android:color/transparent&lt;/item&gt; &lt;item name="android:windowBackground"&gt;@android:color/transparent&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt; &lt;item name="android:windowSoftInputMode"&gt;adjustPan|stateVisible&lt;/item&gt; &lt;item name="android:backgroundDimEnabled"&gt;false&lt;/item&gt;&lt;/style&gt; Dialog12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class MyDialog(context: Context, private val callback: Callback) : Dialog(context, R.style.Dialog) &#123; companion object &#123; private const val TAG = "MyDialog" &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.mydioalog) window?.attributes = window?.attributes?.apply &#123; width = WindowManager.LayoutParams.MATCH_PARENT // 因为 adjustPan 在键盘弹出后布局高度大于屏幕上除键盘之外的可用区域的高度时才会起效， // 而我们监听的就是布局在键盘弹出与收起时可见区域的高度的变化，从而判断键盘当前的状态的。 // 但是不同的手机屏幕高度不同，所以需要动态设置。 // 可用高度 = 屏幕高度 - 状态栏高度 height = Resources.getSystem().displayMetrics.heightPixels - getStatusBarHeight() gravity = Gravity.BOTTOM &#125; rootView.viewTreeObserver.addOnGlobalLayoutListener &#123; val decorView = window.decorView val visibleDisplayRect = Rect() // 检测当前视图所在的 Window 可见区域的大小 decorView.getWindowVisibleDisplayFrame(visibleDisplayRect) val visibleHeight = decorView.height Log.d(TAG, "visibleHeight $visibleHeight") when &#123; decorViewVisibleHeight == 0 -&gt; &#123; // do nothing &#125; decorViewVisibleHeight &gt; visibleDisplayRect.height() -&gt; callback.onKeyboardShow() else -&gt; callback.onKeyboardDismiss() &#125; decorViewVisibleHeight = visibleHeight &#125; &#125; /** * 获取状态栏高度 */ private fun getStatusBarHeight(): Int &#123; val resourceId = Resources.getSystem().getIdentifier( "status_bar_height", "dimen", "android" ) return if (resourceId &gt; 0) &#123; context.resources.getDimensionPixelSize(resourceId) &#125; else &#123; TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_DIP, 25f, Resources.getSystem().displayMetrics ).toInt() &#125; &#125; private var decorViewVisibleHeight = 0 interface Callback &#123; /** * 键盘弹出 */ fun onKeyboardShow() /** * 键盘收起 */ fun onKeyboardDismiss() &#125;&#125; 添加显示 Dialog 的点击事件在 Activity 中添加一个按钮，并为它添加点击事件如下： 12345678910button.setOnClickListener &#123; MyDialog(this, object : MyDialog.Callback &#123; override fun onKeyboardShow() &#123; textView.text = "键盘显示" &#125; override fun onKeyboardDismiss() &#123; textView.text = "键盘隐藏" &#125; &#125;).show()&#125; 此时已经可以监听到键盘的弹出与收起事件了，但是仔细看输入框会发现下半部分被键盘盖住了。 解决问题经过研究发现这与 EditText 的 background 属性有关，先把 android:background=&quot;@null&quot; 去掉，效果如下： 那么 background 设置为 null 与默认值的差别在哪里呢？我们通过 EditText 的源码找一下答案。 12345678910public class EditText extends TextView &#123; public EditText(Context context) &#123; this(context, null); &#125; public EditText(Context context, AttributeSet attrs) &#123; this(context, attrs, com.android.internal.R.attr.editTextStyle); &#125;...&#125; 从源码中可以看出 EditText 的默认 style 为 com.android.internal.R.attr.editTextStyle，接下来全局搜索看一下这个 style 的特征： 一路追踪 parent，最终发现顶级 parent 如下： 12345&lt;style name="Widget.EditText"&gt; ... &lt;item name="background"&gt;?attr/editTextBackground&lt;/item&gt; ...&lt;/style&gt; 再全局搜索 editTextBackground 关键字： 从图中可以看出有很多 item 的 name 是 editTextBackground，随便打开一个，这里就以图中选中的为例，打开文件如下： 1234567891011121314151617181920&lt;inset xmlns:android="http://schemas.android.com/apk/res/android" android:insetLeft="@dimen/edit_text_inset_horizontal_material" android:insetRight="@dimen/edit_text_inset_horizontal_material" android:insetTop="@dimen/edit_text_inset_top_material" android:insetBottom="@dimen/edit_text_inset_bottom_material"&gt; &lt;selector&gt; &lt;item android:state_enabled="false"&gt; &lt;nine-patch android:src="@drawable/textfield_default_mtrl_alpha" android:tint="?attr/colorControlNormal" /&gt; &lt;/item&gt; &lt;item android:state_pressed="false" android:state_focused="false"&gt; &lt;nine-patch android:src="@drawable/textfield_default_mtrl_alpha" android:tint="?attr/colorControlNormal" /&gt; &lt;/item&gt; &lt;item&gt; &lt;nine-patch android:src="@drawable/textfield_activated_mtrl_alpha" android:tint="?attr/colorControlActivated" /&gt; &lt;/item&gt; &lt;/selector&gt;&lt;/inset&gt; 可以看到是通过 xml 设置了一个 InsetDrawable，这里效果如同给 EditText 设置 padding。所以我们给 EditText 添加 paddingTop 和 paddingBottom，运行后发现效果 OK。 使用 FragmentDialog 注意因为 FragmentDialog 是一个 Fragment，所以既可以通过 getActivity().getWindow() 也可以使用 dialog.getWindow()，但是要注意这里应该使用 dialog.getWindow()，反之将不会有预期效果。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Dialog</tag>
        <tag>键盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客进化史]]></title>
    <url>%2Fposts%2F61f01eb0.html</url>
    <content type="text"><![CDATA[个人博客是一个不断进化的过程，在这里记录下博客优化的点点滴滴。 2019年08月07日 使用 hexo_resize_image 支持在 markdown 中设置图片大小。 2019年08月05日 文章链接使用 hexo-abbrlink 支持文章 Id。 使用 hexo-tag-aplayer 支持背景音乐。 音乐直链搜索 2019年08月01日 SEO 优化 参考文章 https://chenhuichao.com/2018/04/13/seo/seo-search-engine-principle/ https://www.jianshu.com/p/9c2d6db2f855 https://accelerator-blog.com/2019/07/27/%E5%8D%9A%E5%AE%A2%E5%8A%9F%E8%83%BD%E4%BC%98%E5%8C%96/ 使用 hexo-generator-sitemap 和 hexo-generator-baidu-sitemap 生成站点地图 使用 hexo-symbols-count-time 支持字数统计 使用 hexo-generator-searchdb 支持站内搜索 2019年05月28日 开始使用 Hexo 搭建个人博客。]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字符编码的历史演变]]></title>
    <url>%2Fposts%2Fa082b9c.html</url>
    <content type="text"><![CDATA[因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制 11111111 = 十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。 ASCII 编码的诞生由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为 ASCII 编码，比如大写字母 A 的编码是65，小写字母 z 的编码是122。 但是要处理中文，显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了 GB2312 编码，用来把中文编进去。 八仙过海，各显神通但全世界有上百种语言，日本把日文编到 Shift_JIS 里，韩国把韩文编到Euc-kr 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。 Unicode 为统一而生为了避免各国之间的编码冲突，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。 UTF-8 来优化 Unicode本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间： 字符 ASCII Unicode UTF-8 A 01000001 00000000 01000001 01000001 中 x 01001110 00101101 11100100 10111000 10101101 从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分。 如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。 总结搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式： 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。 参考文章https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000 开源工具推广你还在为开发中频繁切换环境打包而烦恼吗？快来试试 Environment Switcher 吧！使用它可以在app运行时一键切换环境，而且还支持其他贴心小功能，有了它妈妈再也不用担心频繁环境切换了。https://github.com/CodeXiaoMai/EnvironmentSwitcher]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EnvironmentSwitcher]]></title>
    <url>%2Fposts%2F1d56b016.html</url>
    <content type="text"><![CDATA[Environment Switcher 是一个在 Android 的开发和测试阶段，运用 Java 注解、APT、反射、混淆等原理来一键切换环境的工具。 目前该项目已经达成如下成就： 它具有以下特点： 配置简单 安全，不泄漏测试环境地址 不用重新打包即可一键切换环境 支持按模块配置与切换环境 支持环境切换通知回调 自动生成 切换 保存 获取 环境的逻辑代码 与项目解耦 …… 为什么不用 Gradle看到这里你可能会想，这些功能我用 Gradle 就能搞定了，为什么要用 Environment Switcher 呢？别着急，下面我们来比较一下 Environment Switcher 和 Gradle。 比较内容 Environment Switcher Gradle Application Id 不同 Gradle Application Id 相同 运行时切换环境 ✔️ ✖️ ✖️ 切换环境回调 ✔️ ✖️ ✖️ 切换环境逻辑 自动生成 需要自己实现 需要自己实现 n 套环境打包数量 1个 n个 n个 多套环境同时安装 ✔️ ✔️ ✖️ 支付等SDK包名校验 ✔️ ✖️ ✔️ 多模块环境配置 ✔️ ✔️ ✔️ 测试环境不泄露 ✔️ ✔️ ✔️ …… —— —— —— 这里就先列举这么多，仅 运行时切换环境 、打包数量、切换环境回调 这几个特点就比 Gradle 方便很多，而且 Environment Switcher 的接入成本也很低。是不是想试一试了？ 使用方法 module environmentswitcher environmentswitcher-compiler environmentswitcher-compiler-release version 配置项目的 build.gradlejava 版123456dependencies &#123; ... implementation &quot;com.xiaomai.environmentswitcher:environmentswitcher:$version&quot; debugAnnotationProcessor &quot;com.xiaomai.environmentswitcher:environmentswitcher-compiler:$version&quot; releaseAnnotationProcessor &quot;com.xiaomai.environmentswitcher:environmentswitcher-compiler-release:$version&quot;&#125; kotlin 版12345678apply plugin: &apos;kotlin-kapt&apos;...dependencies &#123; ... implementation &quot;com.xiaomai.environmentswitcher:environmentswitcher:$version&quot; kaptDebug &quot;com.xiaomai.environmentswitcher:environmentswitcher-compiler:$version&quot; kaptRelease &quot;com.xiaomai.environmentswitcher:environmentswitcher-compiler-release:$version&quot;&#125; 编写 EnvironmentConfig 文件这个类是 Environment Switcher 依赖的核心代码，所有获取、修改环境的逻辑代码都会依赖这个类中被 @Module 和 @Environment 两个注解标记的类和属性自动生成。 注意：如果你的项目中使用了 Kotlin，请使用 Java 语言编写 EnvironmentConfig，暂时还不支持使用 Kotlin 编写这个类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 环境配置类&lt;/br&gt; * * ⚠ 建议不要引用该类中的任何子类和成员变量，一但引用了非正式环境的属性，打包时混淆工具就不会移除该类，导致测试地址泄漏。&lt;/br&gt; * Environment Switcher 在编译 Release 版本时，会自动隐藏测试环境地址。&lt;/br&gt;&lt;/br&gt; * * 建议将该类中所有被 &#123;@link Module&#125; 和 &#123;@link Environment&#125; 修饰的类或成员变量用 private 修饰，&lt;/br&gt; * Environment Switcher 会在编译期间自动生成相应的 Module_XX 和 Environment_XX 静态常量。&lt;/br&gt; * 例如：通过 EnvironmentSwitcher.MODULE_APP 就可以获取到 App 模块下相应的所有环境&lt;/br&gt; */public class EnvironmentConfig &#123; /** * 整个 App 的环境 */ @Module private class App &#123; @Environment(url = &quot;https://gank.io/api/&quot;, isRelease = true, alias = &quot;正式&quot;) private String online; &#125; /** * 特殊模块 Music 的环境 */ @Module(alias = &quot;音乐&quot;) private class Music &#123; @Environment(url = &quot;https://www.codexiaomai.top/api/&quot;, isRelease = true, alias = &quot;正式&quot;) private String online; @Environment(url = &quot;http://test.codexiaomai.top/api/&quot;, alias = &quot;测试&quot;) private String test; &#125; /** * 特殊模块 News 的环境 */ @Module(alias = &quot;新闻&quot;) private class News &#123; @Environment(url = &quot;http://news/release/&quot;, isRelease = true, alias = &quot;正式&quot;) private String release; @Environment(url = &quot;http://news/test/&quot;, alias = &quot;测试&quot;) private String test; @Environment(url = &quot;http://news/test1/&quot;) private String test1; @Environment(url = &quot;http://news/sandbox/&quot;, alias = &quot;沙箱&quot;) private String sandbox; &#125;&#125; @Module被它修饰的类或接口表示一个模块，编译时会自动生成相应模块的 getXXEnvironment() 和 setXXEnvironment() 方法。一个被 @Module 修饰的类中，可以有 n (n&gt;0) 个被 @Environment 修饰的属性，表示该模块中有 n 种环境。 例如：上面的代码中，有三个类被 @Module 修饰，意味着有三个模块，其中 App 模块中，只有一个属性被 @Environment 修饰，表示该模块只有一种环境；而 Music 和 News 模块分别有 2 种和 4 种环境。 此外 @Module 还有一个可选属性 alias ，用来指定该模块的别名。该值默认为空字符串。这个属性的主要目的是在切换环境 UI 页面显示中文名称。例如：Music 和 News 模块在切换环境页面中就会分别显示 “音乐” 和 “新闻”。 注：如果你的项目中所有模块共用同一个 Host 地址，那么只需配置一个 Module 就可以了。 @Environment被它修饰的属性表示一个环境，必须指定 url 的值，此外还有两个可选属性：isRelease 和 alias。 isRelease 是一个 boolean 型的属性，默认为 false，当值为 true 时，它就是所在 Module 的默认环境，以及 App 正式发布时的环境。一个 Module 中必须有且只有一个 Environment 的 isRelease 的值为 true，否则编译会失败。 例如：Music 模块中有两种环境分别是 online（正式）和 test （测试），因为 online 的 isRelease = true，所以它就是默认环境和App 正式发布时的环境。 alias 和 @Module 中的 alias 相似，用于在切换环境的UI页面展示该环境的名字，该值默认为空字符串，如果给它指定非空字符串，则环境的名字就被指定为 alias 的值。 再次强调：一个 Module 中必须有且只有一个 Environment 的 isRelease 的值为 true，否则编译会失败。 点击菜单栏中的 “Build” -&gt; “Rebuild Project”，等待编译完成。到这里整个配置就算完成了，接下来就可以在项目中愉快的获取相应模块的环境地址了。 添加入口手动切换环境当然要有一个页面，这个页面 Environment Switcher 已经自动集成了，只需要添加一个入口跳转即可（这个入口只在 Debug 测试等内部版显示）。 例如：在“我的”页面中。 1234567891011121314151617@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; ... if (!BuildConfig.DEBUG) &#123; // only show in debug findViewById(R.id.bt_switch_environment).setVisibility(View.GONE); return; &#125; findViewById(R.id.bt_switch_environment).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // entrance of switch environment EnvironmentSwitchActivity.launch(getContext()); &#125; &#125;);&#125; 你可以使用 Environment Switcher 已经提供的 EnvironmentSwitchActivity.launch(getContext()) 方法启动；当然你也可以通过 startActivity(new Intent(getContext(), EnvironmentSwitchActivity.class)) 启动，看个人喜好了。 获取相应模块的环境地址：123String appEnvironment = EnvironmentSwitcher.getAppEnvironment(this, BuildConfig.DEBUG);String musicEnvironment = EnvironmentSwitcher.getMusicEnvironment(this, BuildConfig.DEBUG);String newsEnvironment = EnvironmentSwitcher.getNewsEnvironment(this, BuildConfig.DEBUG); 获取相应模块的环境实体类(since 1.4)：123EnvironmentBean appEnvironmentBean = EnvironmentSwitcher.getAppEnvironmentBean(this, BuildConfig.DEBUG);EnvironmentBean musicEnvironmentBean = EnvironmentSwitcher.getMusicEnvironmentBean(this, BuildConfig.DEBUG);EnvironmentBean newsEnvironmentBean = EnvironmentSwitcher.getNewsEnvironmentBean(this, BuildConfig.DEBUG); 这里需要注意的是获取相应模块的地址需要两个参数。 第一个就是一个 Context 不用解释，因为 Environment Switcher 是用 SharedPreferences 进行存储数据的。 第二个参数是一个 boolean 型的值，如果为 true 表示当前为 Debug 或测试等内部使用版本，此时获取到的地址是我们手动切换保存的地址；而如果为 false 表示当前为要发布给用户使用的版本，此时获取到的地址为我们在 @Environment 中指定 isRelease = true 的地址，手动切换的环境地址不再生效。 添加监听事件Environment Switcher 支持切换环境回调，你可以通过以下方法添加，需要注意的是不要忘记在不需要监听环境切换事件时移除监听事件。 123456789101112131415161718192021222324public class MainActivity extends AppCompatActivity implements OnEnvironmentChangeListener&#123; private static final String TAG = &quot;MainActivity&quot;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 添加监听事件 EnvironmentSwitcher.addOnEnvironmentChangeListener(this); &#125; @Override public void onEnvironmentChanged(ModuleBean module, EnvironmentBean oldEnvironment, EnvironmentBean newEnvironment) &#123; Log.e(TAG, module.getName() + &quot;由&quot; + oldEnvironment.getName() + &quot;环境，Url=&quot; + oldEnvironment.getUrl() + &quot;,切换为&quot; + newEnvironment.getName() + &quot;环境，Url=&quot; + newEnvironment.getUrl()); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // 移除监听事件 EnvironmentSwitcher.removeOnEnvironmentChangeListener(this); &#125;&#125; 切换SDK开发环境我们在项目中一般会依赖第三方提供的SDK，而且这些SDK也会提供测试环境，如果要在App内切换环境，使用上面的方法就不行了。那该怎么办呢？ 例如我们的“直播”模块是引用的SDK，我们可以这样做： 首先在 EnvironmentConfig.java 中配置”直播”模块 12345678910public class EnvironmentConfig &#123; @Module(alias = &quot;直播&quot;) private class Live &#123; @Environment(url = &quot;online&quot;, isRelease = true, alias = &quot;正式&quot;) private String online; @Environment(url = &quot;test&quot;, alias = &quot;测试&quot;) private String test; &#125;&#125; url 在这里只是用来区分环境，不用为真实的 url，但要保证同一模块中每个环境的 url 不同。 在 Application 中添加监听 123456789101112EnvironmentSwitcher.addOnEnvironmentChangeListener(new OnEnvironmentChangeListener() &#123; @Override public void onEnvironmentChanged(ModuleBean module, EnvironmentBean oldEnvironment, EnvironmentBean newEnvironment) &#123; if (module.equals(EnvironmentSwitcher.MODULE_LIVE)) &#123; if (newEnvironment.equals(EnvironmentSwitcher.LIVE_ONLINE_ENVIRONMENT)) &#123; // 调用 SDK 切换环境的方法，正式环境 &#125; else if (newEnvironment.equals(EnvironmentSwitcher.LIVE_TEST_ENVIRONMENT)) &#123; // 调用 SDK 切换环境的方法，测试环境 &#125; &#125; &#125;&#125;); 利用 Environment Switcher 的环境切换回调，实现切换 SDK 环境。 好了，关于Environment Switcher 的介绍就到此为止吧，更多使用介绍可参考Demo，Demo 中有 Environment Switcher 结合 Retrofit 使用的详细实现过程。]]></content>
      <categories>
        <category>开源</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>EnvironmentSwitcher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentModificationException 异常分析与解决方法]]></title>
    <url>%2Fposts%2F9041b2de.html</url>
    <content type="text"><![CDATA[本文主要从源码的角度分析 ConcurrentModificationException 发生的原因，以及解决办法。 需求与实现需求：从一个集合中找出指定的元素并将其删除。 问题代码： 1234567891011121314ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; list.add(i);&#125;list.forEach(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) &#123; if (integer == 5) &#123; list.remove(integer); &#125; &#125;&#125;); 异常堆栈： 12345Exception in thread "main" java.util.ConcurrentModificationException at java.util.ArrayList.forEach(ArrayList.java:1260) ...Process finished with exit code 1 原因排查从异常的堆栈信息中可以看出，在 ArrayList 的 forEach() 方法中抛出异常，那就先看一下这个方法。 1234567891011121314151617public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings("unchecked") final E[] elementData = (E[]) this.elementData; final int size = this.size; // 循环体内代码执行需要满足的条件有两个： // 1. modCount == expectedModCount // 2. i &lt; size for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; 经过对 forEach() 方法的源码分析，发现 modCount != expectedModCount 会导致 for 循环退出，并且抛出 ConcurrentModificationException。 从第 3 行代码 final int expectedModCount = modCount 中可以知道，初始状态 expectedModCount 和 modCount 的值是相等的，那么是什么原因导致它们的值不相等进而抛出异常的呢？ 原因是 ArrayList 的修改操作（remove 或 add）会导致 modCount 的值发生变化。这里以 remove 方法为例进行分析证明： 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 读完上面的源码会发现 remove 方法并没有修改 modCount 的值啊。别着急，再仔细观察会发现无论怎样，最终会执行 fastRemove 方法。再来看一下这个方法的实现： 123456789private void fastRemove(int index) &#123; // 修改 modCount modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 这次没错了吧。 所以在 forEach() 方法中使用 ArrayList.remove() 删除元素会抛出异常的原因是：由于 ArrayList 执行 remove 方法后，modCount 的值加 1，当 forEach 中的循环检查两个条件时，会因 modCount == expectedModCount 不成立导致 for 循环退出，进而抛出 ConcurrentModificationException 异常。 由此可见，forEach 循环只适用于对 ArrayList 的遍历，但是不可以对 ArrayList 进行添加或删除操作，否则将抛出异常。 现在问题的原因找到了，那么我们应该怎么解决呢？ 解决办法方法一：使用普通的 for 循环1234567891011ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; list.add(i);&#125;for (int i = 0; i &lt; list.size(); i++) &#123; if (i == 5) &#123; list.remove(i); &#125;&#125; 运行代码，发现没有抛出异常。问题解决！ 但是，如果需求改为删除所有元素呢？ 12345678910111213ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; list.add(i);&#125;for (int i = 0; i &lt; list.size(); i++) &#123; list.remove(i);&#125;int size = list.size();System.out.println("执行完毕 list.size() = " + size); 先猜一下运行结果是什么，再往下看。 ——– 这里是分隔线（这里先插播一条广告，广告之后更加精彩！哈哈！！！）———— 你还在为开发中频繁切换环境打包而烦恼吗？快来试试 Environment Switcher 吧！使用它可以在app运行时一键切换环境，而且还支持其他贴心小功能，有了它妈妈再也不用担心频繁环境切换了。https://github.com/CodeXiaoMai/EnvironmentSwitcher目前该项目已经达成如下成就： ——————- 这里是分隔线（广告结束，精彩继续！！！）——————– 好了，回归正题你猜出结果了吗？看看你猜的对下对。 运行结果为： 1执行完毕 list.size() = 5 咦？明明是遍历 list 的每个元素并把它们删除，为什么最后还有 5 个元素呢？ 这是因为 ArrayList 内部使用数组存储数据，10 个元素依次存储在数组的第 0 个位置开始到第 9 个位置，当中间有一个元素删除时，后面的所有元素会向前移动，保证中间没有空余。所以当第 0 个位置的元素删除完毕后，本来在第 1 个位置的元素变成第 0 个元素，但由于 i++ 后 i = 1，下次执行删除操作时会删除最新的第 1 个位置的元素，而第 0 个位置的元素因被跳过而不会被删除，同理当后面的元素被删除时也会有跳过，这就是为什么最终会有 5 个元素的原因。 所以如果只是在遍历 ArrayList 的同时删除指定的元素后并退出循环，这样是没有问题的，因为删除元素后，不会进行其他操作。但是如果删除所有元素，就需要做一些特殊的处理了，具体处理如下： 1234for (int i = 0; i &lt; list.size(); i++) &#123; list.remove(i); i--;&#125; 方法二：使用 Iterator12345678910111213ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; list.add(i);&#125;Iterator&lt;Integer&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; if (iterator.next() == 5) &#123; iterator.remove(); &#125;&#125; 如果要删除所有元素呢？ 123456789101112ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; list.add(i);&#125;Iterator&lt;Integer&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; iterator.next(); iterator.remove();&#125; 运行结果： 1执行完毕 list.size() = 0 从运行结果可以知道，程序正常运行而且完全符合预期。为什么使用 Iterator 可以正常遍历并且删除所有元素呢？下面从源码的角度分析： 首先看，list.iterator() 的实现： 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 这个方法创建并返回一个 Itr 类的实例。通过查看源码可以发现 Itr 实现了 Iterator 接口，这不正是我们需要的吗？接下来依次看 iterator.hasNext()、iterator.next() 以及 iterator.remove() 方法：（前方高能，请注意准备好脑子！！！） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; // 因为 Itr 是 ArrayList 的内部类，所以可以直接访问 ArrayList 的 modCount。 Itr() &#123;&#125; public boolean hasNext() &#123; // 如果当前 cursor 不指向最后一个元素后面的索引位置， // 说明当前 cursor 所在位置后面还有没有遍历到的元素，返回 true。 return cursor != size; // 因为 Itr 是 ArrayList 的内部类，所以可以直接访问 ArrayList 的 size。 &#125; /** * 首先检查 modCount == expectedModCount 是否成立， * 如果不成立直接抛出 ConcurrentModificationException； * 否则按下面的逻辑运行： * 返回当前 cursor 所在位置的元素， * lastRet 的值更新为当前 cursor 的值， * cursor 的值加 1，即指向下次要访问的元素位置。 */ @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; /** * 与直接使用 ArrayList 的 remove() 方法不同的是， * 该方法会更新 expectedModCount 的值为 modCount。 * 这也正是为什么通过 List.iterator() 遍历的同时进行 * iterator().remove() 操作，不会发送异常的原因。 */ public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125;&#125; 总结： 使用 List.iterator() 遍历集合的同时进行 iterator().remove() 操作，不会发送异常的原因是：Iterator.remove() 会在执行 ArrayList 的 remove() 后，重新将 expectedModCount 的值更新为 modCount 的值。这样运行 checkForComodification() 方法时，才会正常运行。 方法三：使用增强 for 循环增强 for 循环是迭代器的简化书写格式，和 iterator 遍历的效果是一样的，也就说增强 for 循环的内部也就是调用 iterator 实现的，只不过获取迭代器由 jvm 完成，不需要我们获取迭代器而已。但是增强 for 循环有些缺点，例如不能在增强 for 循环里动态的删除集合内容（虽然内部也使用了 Iterator 但在删除时因为拿不到 Iterator，所以不能通过 Iterator 删除）、不能获取下标等。 所以这种方式只适用于删除一个指定元素后，立即退出循环的情况。 123456789101112ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; list.add(i);&#125;for (Integer integer : list) &#123; if (integer == 5) &#123; list.remove(integer); break; &#125;&#125; 总结经过上面对异常发生的原因以及 3 种解决办法的分析，可以得出以下结论： 只要是在遍历时直接通过调用 ArrayList.remove() 移除元素都是不安全的，普通的 for 循环和增强 for 循环适用于删除一个元素后就退出循环体；而 forEach() 循环是坚决不可以执行删除操作的（因为它是程序员无法控制退出循环的），否则会抛出异常。最安全的方法是使用 Iterator 进行遍历的同时，并且必须使用 Iterator 提供的 remove() 方法进行删除操作。 扩展上面分析是 remove() 操作，那 add() 操作呢？ 按照思路应该也是使用 Iterator 的 add 之类的方法，但是当我们写代码的时候会发现，唉？唉？唉？唉？我 iterator 点，iterator 点…… 为什么没有点出来 add 之类的方法？ 这是因为 Iterator 接口只提供了 remove() 方法，F***K，这可让我如何是好？别急，List 接口还提供了一个 listIterator() 方法，这个方法返回的对象是可以进行 add 操作的，我们来看一看下面的代码： 123456789101112131415161718ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();// 初始化 list 中的值为 0,2,4,6,8for (int i = 0; i &lt; 10; i += 2) &#123; list.add(i);&#125;ListIterator&lt;Integer&gt; iterator = list.listIterator();// 在每个元素后面追加一个比自己大 1 的元素while (iterator.hasNext()) &#123; Integer next = iterator.next(); iterator.add(next + 1);&#125;for (Integer integer : list) &#123; System.out.print(integer);&#125; 运行结果： 10123456789 通过查看源码，可以发现 list.listIterator() 方法如下： 123public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0);&#125; 这个方法返回一个 ListItr 类的实例，并且这个类实现了 ListIterator 接口。 ListIterator 是一个在继承了 Iterator 接口的同时又额外提供了 add() 、set() 等方法的接口，如下图。 再看一下 ListItr 这个类： 12345678910111213141516171819private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ...... /** * 同 Itr 的 remove 方法一样，先在集合中添加元素， * 最后将 modCount 的值赋给 expectedModCount */ public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125;&#125; ListItr 不但实现了 ListIterator 接口，而且继承了 Itr 类（上面已经分析过），从源码中可以发现 ListItr 内没有实现 remove() 方法，显然这是直接复用它的父类 Itr 的 remove() 方法。 所以，如果在遍历的同时只是进行 remove 操作，既可以使用 iterator 也可以使用 listIterator；而要进行 add 操作，就必须使用 listIterator 了。 LinkedList 和 ArrayList 略有不同，虽然它的 iterator() 和 listIterator() 方法返回的接口类型不同，但是仔细分析源码会发现其实内部都是 ListItr 对象。]]></content>
      <categories>
        <category>Java</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>ConcurrentModificationException</tag>
        <tag>ArrayList</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
</search>
